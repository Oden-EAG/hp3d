!----------------------------------------------------------------------
!
!   module name        - module prolongation
!
!----------------------------------------------------------------------
!
!   latest revision    - Jan 18
!
!   purpose            - module supports construction of prolongation
!                        operator for edges and faces
!
!----------------------------------------------------------------------
!
      module prolongation
!
      use element_data
      use parameters
      use data_structure3D
      use constraints
      use refinements_2D
!
      implicit none
!
!     maximum # of generation between coarse and fine mesh
      integer, parameter :: MAXGEN_PR=5
!
!  ...order of approximation for edge or face parent node
      integer :: NORDP, NORDPH, NORDPV
!
!  ...actual and max number of nodes in the temporary data structure
      integer :: NR_NODES_PR, MAX_NODES_PR
!
!  ...prolongation coefficients for parent nodes
      double precision, allocatable :: &
                        COEFFPH(:,:),COEFFPE(:,:),COEFFPV(:,:)
!
!  ...number of parent nodes dof (a function of NORDP)
      integer :: MDOFH,MDOFE,MDOFV
!
!----------------------------------------------------------------------
! 
!  ...node
      type nodePR
!
!  .....node type: 'none','vert','medg','mdlq','mdlt'
        character(len=4) :: type
!
!  .....order
        integer          :: order
!
!  .....global node number 
        integer          :: nod
!
!  .....refinement flag
        integer          :: ref_kind
!
!  .....father
        integer          :: father
!
!  .....sons
        integer , dimension(:), allocatable :: sons
!
!  .....H1 prolongation coefficients
        double precision, dimension(:,:), allocatable :: coeffH
!
!  .....H(curl) prolongation coefficients
        double precision, dimension(:,:), allocatable :: coeffE
!
!  .....H(div) prolongation coefficients
        double precision, dimension(:,:), allocatable :: coeffV
!
      endtype nodePR
!
!  ...nodes
      type(nodePR), allocatable, save :: NODES_PR(:)
!
      CONTAINS
!      
!----------------------------------------------------------------------
!-----------------------------------------------------------------------
!     routine breaks a node in the auxiliary data structure supporting
!     determination of prolongation coefficients for nodes in the
!     interior of a face or edge
!     in:     Nodl - the node to be broken
!-----------------------------------------------------------------------
!
      subroutine nodbreakPR(Nodl)
!
      integer :: Nodl
!
!  ...locals
      integer :: nod,nord,nordx,nordy,kref,iprint,nrsons,is,nson,nrp, &
                 kH,kE,kV,ip,nodpl,ndofH,ndofE,ndofV,ndofQ,jH,jE,jV,  &
                 nsonl,kp,np
!
!  ...nodal sons order, case numbers, dof offsets
      integer :: norder(9),icasel(9),naH(9),naE(9),naV(9)
!
!  ...nodal sons type
      character(len=4) :: type(9)
!
!  ...nodal connectivities for an edge or face
      integer :: nodesl(9)
!
!  ...prolongation coefficients for nodal sons of a node
      integer :: nrconH,nrconE,nrconV,nacH,nacE,nacV
      double precision :: constrH,constrE,constrV
      dimension  nrconH(MAXmdlqH),nrconE(MAXmdlqE),nrconV(MAXmdlqV), &
                 nacH(MaxquadH,MAXmdlqH),constrH(MaxquadH,MAXmdlqH), &
                 nacE(MaxquadE,MAXmdlqE),constrE(MaxquadE,MAXmdlqE), &
                 nacV(MaxquadV,MAXmdlqV),constrV(MaxquadV,MAXmdlqV)
!
!  ...collect the data about the node to be broken (the father)
      nod = NODES_PR(Nodl)%nod
      nord  = NODES_PR(Nodl)%order
      kref = NODES(nod)%ref_kind
!
!  ...record the refinement kind
      NODES_PR(Nodl)%ref_kind = kref 
!
      select case(Nodl)
      case(30)
        iprint=0
      case default
        iprint=0
      end select
!
      if (iprint.eq.1) then
        write(*,7001) Nodl,nod,kref,NODES(nod)%type
 7001   format('nodbreakPR: Nodl,nod,kref,type = ',i6,2x,i4,2x,i2,2x,a4)
      endif
!
!  ...determine number, type, order for the new nodes
      select case(NODES_PR(Nodl)%type)
!
      case('medg')
        nrsons = 3
        type(1:3) = (/'medg','medg','vert'/)
        norder(1:3) = (/nord,nord,1/)
!
      case('mdlt')
        select case(kref)
        case(1)
          nrsons = 7
          type(1:7) = (/'mdlt','mdlt','mdlt','mdlt', &
                        'medg','medg','medg'/)
          norder(1:7) = nord
        end select
!
      case('mdlq')
        call decode(nord, nordx,nordy)
        select case(kref)
        case(01)
          nrsons = 3
          type(1:3) = (/'mdlq','mdlq','medg'/)
          norder(1:3) = (/nord,nord,nordx/)
        case(10)
          nrsons = 3
          type(1:3) = (/'mdlq','mdlq','medg'/)
          norder(1:3) = (/nord,nord,nordy/)
        case(11)
          nrsons = 9
          type(1:9) = (/'mdlq','mdlq','mdlq','mdlq', &
                        'medg','medg','medg','medg','vert'/)
          norder(1:9)=(/nord,nord,nord,nord,nordy,nordx,nordy,nordx,1/)
        end select
!
      end select
!
!  ...generate the new nodes
      allocate(NODES_PR(Nodl)%sons(nrsons))
      do is=1,nrsons
        nson = NODES(nod)%sons(is)
        call nodgenPR(type(is),Nodl,norder(is),nson, &
                      NODES_PR(Nodl)%sons(is))
      enddo
!
!-----------------------------------------------------------------------
!
!  ...determine parent nodes and case numbers for the nodal sons
      select case(NODES_PR(Nodl)%type)
      case('medg')
        call edge_nodesPR(Nodl, nodesl); nrp=3
        icasel(1:3)= (/11,12,13/)
      case('mdlq')
        call face_nodesPR(Nodl, nodesl); nrp=9
        select case(kref)
        case(11)
          icasel(1:9)= (/21,22,23,24,25,26,27,28,29/)
        case default
          write(*,*) 'nodbreakPR: UNFINISHED'; stop 1
        end select
      end select

      if (iprint .eq. 1) then
         write(*,5000) nodesl(1:nrp)
 5000    format('nodbreakPR: nodesl     = ', 9i6)        
         write(*,5001) NODES_PR(nodesl(1:nrp))%nod
 5001    format('nodbreakPR: nodesl nod = ', 9i6)
      endif


!
!  ...collect parent nodes prolongation coefficients end establish
!     offsets for parent nodes dof
!
      kH=0; kE=0; kV=0
      do ip=1,nrp
        naH(ip)=kH ; naE(ip)=kE ; naV(ip)=kV
        nodpl = nodesl(ip)
        call ndof_nod(NODES_PR(nodpl)%type,NODES_PR(nodpl)%order, &
                      ndofH,ndofE,ndofV,ndofQ)

        if (iprint.eq.1) then
          write(*,7010) ip,nodpl,NODES_PR(nodpl)%nod,NODES_PR(nodpl)%type,     &
                        NODES_PR(nodpl)%order, ndofH,ndofE,ndofV,ndofQ
 7010     format('nodbreakPR: ip,nodpl, nod = ',i2,i5,i5,' type = ',a4,' order = ',i2,&
                 ' ndofH,ndofE,ndofV,ndofQ = ',4i4)
        endif
        do jH=1,ndofH
          kH = kH+1
          COEFFPH(1:MDOFH,kH) = NODES_PR(nodpl)%coeffH(1:MDOFH,jH)
        enddo
        do jE=1,ndofE
          kE = kE+1
          COEFFPE(1:MDOFE,kE) = NODES_PR(nodpl)%coeffE(1:MDOFE,jE)
        enddo
        do jV=1,ndofV
          kV = kV+1
          COEFFPV(1:MDOFV,kV) = NODES_PR(nodpl)%coeffV(1:MDOFV,jV)
        enddo
      enddo
!
!  ...generate the prolongation coefficients for the nodal sons
!
!  ...loop through the nodal sons
      do is=1,nrsons
        nsonl = NODES_PR(Nodl)%sons(is)
        call ndof_nod(NODES_PR(nsonl)%type,NODES_PR(nsonl)%order, &
                      ndofH,ndofE,ndofV,ndofQ)
!
!  .....determine prolongation coefficients for the nodal sons
!       wrt to the edge parent nodes
        call logicPR(icasel(is),nord,naH,naE,naV, &
                     nrconH,nacH,constrH, &
                     nrconE,nacE,constrE, &
                     nrconV,nacV,constrV)
        if (iprint.eq.1) then
          write(*,*) 'nodbreakPR: is,nrsons,ndofE = ',is,nrsons,ndofE
        endif
!
!  .....H1 dof
        if (ndofH.gt.0) then
          if (allocated(NODES_PR(nsonl)%coeffH)) &
             deallocate(NODES_PR(nsonl)%coeffH)
          allocate(NODES_PR(nsonl)%coeffH(MDOFH,ndofH))
          NODES_PR(nsonl)%coeffH = 0.d0
          do kH=1,ndofH
            do kp=1,nrconH(kH)
              np = nacH(kp,kH)
              NODES_PR(nsonl)%coeffH(1:MDOFH,kH) = &
              NODES_PR(nsonl)%coeffH(1:MDOFH,kH) + &
              constrH(kp,kH)*COEFFPH(1:MDOFH,np)
            enddo
          enddo
        endif
!
!  .....H(curl) dof
        if (ndofE.gt.0) then
          if (allocated(NODES_PR(nsonl)%coeffE)) deallocate(NODES_PR(nsonl)%coeffE)
          allocate(NODES_PR(nsonl)%coeffE(MDOFE,ndofE))
          NODES_PR(nsonl)%coeffE = 0.d0
          do kE=1,ndofE
            do kp=1,nrconE(kE)
              np = nacE(kp,kE)
              NODES_PR(nsonl)%coeffE(1:MDOFE,kE) = &
              NODES_PR(nsonl)%coeffE(1:MDOFE,kE) + &
              constrE(kp,kE)*COEFFPE(1:MDOFE,np)
            enddo
          enddo
        endif
!
!  .....H(div) dof
        if (ndofV.gt.0) then
          if (allocated(NODES_PR(nsonl)%coeffV)) &
             deallocate(NODES_PR(nsonl)%coeffV)
          allocate(NODES_PR(nsonl)%coeffV(MDOFV,ndofV))
          NODES_PR(nsonl)%coeffV = 0.d0
          do kV=1,ndofV
            do kp=1,nrconV(kV)
              np = nacV(kp,kV)
              NODES_PR(nsonl)%coeffV(1:MDOFV,kV) = &
              NODES_PR(nsonl)%coeffV(1:MDOFV,kV) + &
              constrV(kp,kV)*COEFFPV(1:MDOFV,np)
            enddo
          enddo
        endif
!
!  ...end of loop through the nodal sons
      enddo
!
      end subroutine nodbreakPR
!
!-----------------------------------------------------------------------
!     routine generates a new node in the auxiliary data structure for 
!                        a face or edge of the coarse mesh
!     in:     Type     - the new node type
!             Nafth    - father of the new node
!             Norder   - order of the new node
!             Nod      - global node number
!     out:    Nodl     - the new node local number
!-----------------------------------------------------------------------
!
      subroutine nodgenPR(Type,Nfath,Norder,Nod, Nodl)
!
      character(len=4) :: Type
      integer ::  Nfath, Norder, Nod, Nodl
!
!  ...use pointer to the first free entry to get the new node number
      Nodl = NR_NODES_PR+1
      if (Nodl.gt.MAX_NODES_PR) then
        write(*,*) 'nodgenPR: ERROR !! NO ROOM FOR A NEW NODE!!!'
        stop 1
      endif
      NR_NODES_PR = NR_NODES_PR+1
!
!  ...store node information 
      NODES_PR(Nodl)%type  = Type
      NODES_PR(Nodl)%order = Norder
      NODES_PR(Nodl)%ref_kind = 0
      NODES_PR(Nodl)%father = Nfath
      NODES_PR(Nodl)%nod = Nod
!
      end subroutine nodgenPR
!
!-----------------------------------------------------------------------
!     routine returns element to nodes connectivities using the auxiliary
!     2Ddata structure for a face
!     in:     Mdle     - an element middle node, identified with
!                        the element
!     out:    Nodesl   - element nodes
!-----------------------------------------------------------------------
! 
      subroutine face_nodesPR(Mdle, Nodesl)
!
      integer :: Mdle,Nodesl(9)
!
!  ...history information: father, its type, refinement kind, son number
      character(len=5) :: stype,ftype,father_type,son_type
      dimension father_type(MAXGEN_PR),son_type(MAXGEN_PR)
      integer :: nfather(MAXGEN_PR),nfather_ref_kind(MAXGEN_PR),      &
                 noson(MAXGEN_PR)
!
!  ...local copy of Nodesl, locals
      integer :: nodesl_loc(9),iprint,nfath,nson,igen,nrsons,nrgen,   &
                 iref_fath,j,jp,is,nodp
!
      select case(Mdle)
      case(45)
        iprint=0
      case default
        iprint=0
      end select
!
      if (iprint.eq.1) then
        write(*,*) '------------------------------------------------'
        write(*,7001) Mdle
 7001   format('face_nodesPR: DEBUGGING FOR Mdle = ',i6)
      endif
!      
      Nodesl=0
!
!  ...Step 1: Go up the tree to the initial mesh ancestor
!     initiate father, son and generation number
      nfath = NODES_PR(Mdle)%father; nson = Mdle; igen=0
      do while(nfath.gt.0)
        igen=igen+1
        nfather(igen) = nfath
        father_type(igen) = NODES_PR(nfath)%type
        son_type(igen) = NODES_PR(nson)%type
        nfather_ref_kind(igen) = NODES_PR(nfath)%ref_kind
        call nr_mdle_sons(NODES_PR(nfath)%type,NODES_PR(nfath)%ref_kind, &
                          nrsons)
        call locate(nson,NODES_PR(nfath)%sons,nrsons, noson(igen))
        nson = nfath
        nfath = NODES_PR(nson)%father
      enddo
      nrgen = igen
!
      if (iprint.eq.1) then
        do igen=1,nrgen
          write(*,7011) igen,nfather(igen),father_type(igen), &
          son_type(igen),nfather_ref_kind(igen),noson(igen)
 7011     format('igen = ',i2,' father = ',i6,' type = ',a5, &
                 ' son type = ',a5, &
                 ' ref_kind = ',i3,' son number = ',i1)
        enddo
      endif
!
!  ...the connectivities for the initial element (just one) are fixed
      select case(NODES_PR(nson)%type)
      case('mdlt')
        Nodesl(1:7) = (/1,2,3,4,5,6,7/)
      case('mdlq')
        Nodesl(1:9) = (/1,2,3,4,5,6,7,8,9/)
      end select
!
!  ...Step 2: Go down the tree reconstructing connectivities
      if (nrgen.eq.0) return
      do igen=nrgen,1,-1
        nson = noson(igen)
        stype = son_type(igen); ftype = father_type(igen)
        iref_fath = nfather_ref_kind(igen)
!
!  .....loop through nodes of the son
        do j=1,nvert(stype)+nedge(stype)+1
!
!  .......parent node
          jp   = npar_ref(ftype, j, nson, iref_fath)
          is   = nson_ref(ftype, j, nson, iref_fath)

          if (iprint.eq.1) then
            write(*,7027) stype,j,nson,ftype,jp,is
 7027       format('elem_nodes: stype,j,nson,ftype,jp,is = ', &
                    a5,2i3,2x,a5,2i3)
            call pause
          endif
!
!  .......a node shared with the father
          if (is.eq.0) then
            if (jp.eq.0) then
              nodesl_loc(j) = Nodesl(j)
            else
              nodesl_loc(j) = Nodesl(jp)
            endif
!
!  .......a node resulted from breaking
          else
!
!  .........parent node
            nodp = Nodesl(jp)
!
            if (jp.le.nvert(ftype)) then
              write(*,7999) 1; stop 1
!
!  .........parent edge node
            elseif (jp.le.nvert(ftype)+nedge(ftype)) then
              nodesl_loc(j) = NODES_PR(nodp)%sons(is)
!
!  .........parent middle node
            else
              nodesl_loc(j) = NODES_PR(nodp)%sons(is)
            endif
!
!  .......if the node has resulted from breaking a node
          endif
!
!  .....end of loop through nodes of the son
        enddo
!
        Nodesl = nodesl_loc
!
        if (iprint.eq.1) then
          write(*,7031) igen,NODES_PR(nfather(igen))%sons(nson)
 7031     format('elem_nodes: igen = ',i2,' NODES_PR FOR mdle = ',i6)
          select case(son_type(igen))
          case('mdlt')
            write(*,7101) Nodesl(1:7)
          case('mdlq')
            write(*,7102) Nodesl(1:9)
          end select
        endif
      enddo
      if (iprint.eq.1) call pause
!
 7999 format('face_nodesPR: INCONSISTENCY ',i2)
!
!  ...formats for printing element nodes and orientations
 7101 format(3i6,2x,3i6,2x,i6)
 7102 format(4i6,2x,4i6,2x,i6)
!
!
      end subroutine face_nodesPR

!-----------------------------------------------------------------------
!     routine returns element to nodes connectivities using the auxiliary
!     1Ddata structure for an edge
!     in:     Mdle     - an element middle node, identified with
!                        the element
!     out:    Nodesl   - element nodes
!-----------------------------------------------------------------------
!
      subroutine edge_nodesPR(Mdle, Nodesl)
!
      integer :: Mdle, Nodesl(3)
!
!  ...locals
      integer :: no_son(MAXGEN_PR),nodesl_new(3),iprint,nson,igen,nfath,&
                 nodesf(9),is,nrs
!
      select case(Mdle)
      case(8)
        iprint=0
      case default
        iprint=0
      end select
      if (iprint.eq.1) then
        write(*,7000) Mdle
 7000   format('edge_nodesPR: Mdle = ',i8)
      endif
!
!  ...go up the tree recording the son number
      nson=Mdle
      igen=0
      do
        nfath = NODES_PR(nson)%father
        if (nfath.lt.0) then
          select case(nson)
          case(3); Nodesl(1:3) = (/1,2,3/) ! 1D data structure
          case(5); Nodesl(1:3) = (/1,2,5/) ! 2D data structure
          case(6); Nodesl(1:3) = (/2,3,6/)
          case(7); Nodesl(1:3) = (/4,3,7/)
          case(8); Nodesl(1:3) = (/1,4,8/)
          end select
          exit
        endif
        if (NODES_PR(nfath)%type.ne.'medg') then
          call face_nodesPR(nfath, nodesf)
          call nr_sons(NODES_PR(nfath)%type,NODES_PR(nfath)%ref_kind, nrs)
          call locate(nson,NODES_PR(nfath)%sons,nrs, is)
          select case(NODES_PR(nfath)%ref_kind)
          case(11)
            select case(is)
            case(5)
              Nodesl(1) = NODES_PR(nodesf(5))%sons(3)
              Nodesl(2) = NODES_PR(nfath)%sons(9)
            case(6)
              Nodesl(2) = NODES_PR(nodesf(6))%sons(3)
              Nodesl(1) = NODES_PR(nfath)%sons(9)
            case(7)
              Nodesl(2) = NODES_PR(nodesf(7))%sons(3)
              Nodesl(1) = NODES_PR(nfath)%sons(9)
            case(8)
              Nodesl(1) = NODES_PR(nodesf(8))%sons(3)
              Nodesl(2) = NODES_PR(nfath)%sons(9)
            end select
            Nodesl(3) = nson
          case default
            write(*,*) 'edge_nodes: UNFINISHED'; stop 1
          end select
          exit
        endif
        igen=igen+1
        call locate(nson, NODES_PR(nfath)%sons(1:2),2, no_son(igen))
        nson = nfath
        if (iprint.eq.1) then
          write(*,7001) no_son(1:igen)
 7001     format('edge_nodesPR: no_son = ',10i5)
        endif
      enddo
!
      do 
         nfath = Nodesl(3)
         if (igen.eq.0) exit
         select case(no_son(igen))
         case(1)
            nodesl_new(1) = Nodesl(1)
            nodesl_new(2) = NODES_PR(nfath)%sons(3)
            nodesl_new(3) = NODES_PR(nfath)%sons(1)
         case(2)
            nodesl_new(1) = NODES_PR(nfath)%sons(3)
            nodesl_new(2) = Nodesl(2)
            nodesl_new(3) = NODES_PR(nfath)%sons(2)
         end select
         if (iprint.eq.1) then
            write(*,7002) igen, nodesl_new(1:3)
 7002       format('edge_nodesPR: igen = ',i2,' nodesl_new = ',3i5)
         endif
         igen = igen-1
         Nodesl = nodesl_new
      enddo
      if (iprint.eq.1) then
        write(*,7003) Mdle,Nodesl(1:3)
 7003   format('edge_nodesPR: Mdle,Nodesl = ',i8,3x,3i8)
        call pause
      endif
!
!
      end subroutine edge_nodesPR
!
!-----------------------------------------------------------------------
!     routine is a calc copy of system routine 'logic', it returns
!     prolongation coefficients for dof of nodal sons of an edge or face
!     node
!     in:     Icase    - case flag, see module `constraints' and routine
!                        `logic' for a detailed explanation
!             Nord     - order of parent edge or face node
!             NaH,NaE,NaV - offsets for parent nodes dof

!     out:    prolongation data
!     REMARK: order of parent nodes implies the order of nodal sons,
!             if sons are of higher order, the prolongation coefficients
!             are zero, if their order happens to be lower, the
!             corresponding prolongation coefficients should be 
!             disregarded in the calling routine
!-----------------------------------------------------------------------
!
      subroutine logicPR(Icase,Nord,NaH,NaE,NaV, &
                         NrconH,NacH,ConstrH, &
                         NrconE,NacE,ConstrE, &
                         NrconV,NacV,ConstrV)
!
      integer :: Icase,Nord,NaH(9),NaE(9),NaV(9)
      integer :: NrconH,NrconE,NrconV,NacH,NacE,NacV
      double precision :: ConstrH,ConstrE,ConstrV
      dimension NrconH(MAXmdlqH),NrconE(MAXmdlqE),NrconV(MAXmdlqV), &
                NacH(MaxquadH,MAXmdlqH),ConstrH(MaxquadH,MAXmdlqH), &
                NacE(MaxquadE,MAXmdlqE),ConstrE(MaxquadE,MAXmdlqE), &
                NacV(MaxquadV,MAXmdlqV),ConstrV(MaxquadV,MAXmdlqV)
      
!
!  ...local variables
      integer :: kH,kE,kV,loc,ndofH,ndofE,ndofV,l,jp,lp,is,ish,isv,&
                 ndofHh,ndofEh,ndofVh,ndofHv,ndofEv,ndofVv,lpv,lph, &
                 lv,lh,nordh,nordv,iprint,iv,ip
      integer :: ndofHp(4),ndofEp(4),locp(4)
!
!     initialize number of connected parent dof
      NrconH=0; NrconE=0; NrconV=0
!
      iprint=0
!
!     initialize local H1, H(curl), H(div) dof counters
      kH=0 ; kE=0 ; kV=0
!
      select case(Icase)
!
!  ...FIRST AND SECOND MID-EDGE NODE CONSTRAINED BY AN EDGE
      case(11,12)
!
!       parent mid-edge node
        loc=3; ndofH = Nord-1; ndofE = Nord
        select case(Icase)
        case(11); is=1
        case(12); is=2
        end select
!
!       H1-loop through nodal dof
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~
        do l=1,ndofH
          kH=kH+1
          NrconH(kH) = ndofH
!
!         loop through parent node dof's
          do jp=1,ndofH
!
!           parent dof location
            NacH(   jp,kH)=NaH(loc)+jp
!
!           prolongation coefficient
            ConstrH(jp,kH)=RRRH(1,jp,is,l)
          enddo
        enddo
!
!       H(curl)-loop through nodal dof
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        do l=1,ndofE
          kE=kE+1
          NrconE(kE) = ndofE
!
!         loop through parent node dof's
          do jp=1,ndofE
            NacE(   jp,kE)=NaE(loc)+jp
            ConstrE(jp,kE)=RRRE(1,jp,is,l)
          enddo
        enddo
!
!  ...VERTEX NODE CONSTRAINED BY AN EDGE
      case(13)
!
!       H1 single dof ONLY
!       ~~~~~~~~~~~~~~~~~~
!
!       parent mid-edge node
        loc=3; ndofH = Nord-1; ndofE = Nord 
!
        kH=kH+1
        NrconH(kH)=Nord+1
!
!       initialize parent dof local number
        jp=0
!
!       STEP 1 : loop through parent mid-edge node dofs
        do lp=1,ndofH
!
!         advance parent dof local number
          jp=jp+1
!
!         parent dof location
          NacH(   jp,kH)=NaH(loc)+lp
!
!         prolongation coefficient
          ConstrH(jp,kH)=RRRH(1,lp,3,1)
        enddo
!
!       STEP 2 : loop through parent edge vertex dofs
        do iv=1,2
!
!         parent vertex node location on the list of parent nodes
          loc = iv
!
!         advance parent dof local number
          jp=jp+1
!
!         parent dof location
          NacH(   jp,kH)=NaH(loc)+1
!
!         prolongation coefficient
          ConstrH(jp,kH)=RRRH(1+iv,1,3,1)
!
!       end of loop through vertex parent nodes
        enddo
!
!  ...MID-FACE NODE CONSTRAINED BY AN H4-REFINED FACE 
      case(21,22,23,24)
!
!       determine horizontal and vertical son number
        select case(Icase)
        case(21) ; ish=1 ; isv=1
        case(22) ; ish=2 ; isv=1
        case(23) ; ish=2 ; isv=2
        case(24) ; ish=1 ; isv=2
        end select
!
!  .....parent mid-face node
        loc=9
!
!  .....number of parent node horizontal and vertical dof's
        call decode(Nord, nordh,nordv)
        ndofHh = nordh-1 ; ndofEh = nordh
        ndofHv = nordv-1 ; ndofEv = nordv
!
!       H1-loop through the constrained mid-face node dof's
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        do lv=1,ndofHv
          do lh=1,ndofHh
!
!           advance dof counter
            kH=kH+1
!
!           number of parent dof's
            NrconH(kH) = ndofHv*ndofHh
!
!           initialize parent dof local number
            jp=0
!
!           loop through the parent node dof
            do lpv=1,ndofHv
              do lph=1,ndofHh
!
!               advance parent dof local number
                jp=jp+1
!
!               parent dof location
                NacH(   jp,kH)=NaH(loc)+(lpv-1)*ndofHh+lph
!
!               constraint coefficient
                ConstrH(jp,kH)=RRRH(1,lph,ish,lh)*RRRH(1,lpv,isv,lv)
              enddo
            enddo
          enddo
        enddo
!
!       H(curl)-loop through the constrained mid-face node dof
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       STEP 1 : horizontal dof's first
        do lv=1,ndofHv
          do lh=1,ndofEh
            kE=kE+1; jp=0
            NrconE(kE) = ndofHv*ndofEh
            do lpv=1,ndofHv
              do lph=1,ndofEh
                jp=jp+1
                NacE(jp,kE)   =NaE(loc)+(lpv-1)*ndofEh+lph
                ConstrE(jp,kE)=RRRE(1,lph,ish,lh)*RRRH(1,lpv,isv,lv)
              enddo
            enddo
          enddo
        enddo
!
!       STEP 2 : vertical dof's next
        do lv=1,ndofEv
          do lh=1,ndofHh
            kE=kE+1; jp=0
            NrconE(kE) = ndofEv*ndofHh
            do lpv=1,ndofEv
              do lph=1,ndofHh
                jp=jp+1
                NacE(jp,kE)   = NaE(loc) + ndofEh*ndofHv &
                              + (lpv-1)*ndofHh+lph
                ConstrE(jp,kE)=RRRH(1,lph,ish,lh)*RRRE(1,lpv,isv,lv)
              enddo
            enddo
          enddo
        enddo
!
!       H(div)-loop through the constrained mid-face node dof's
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
!       horizontal first then vertical
        do lv=1,ndofEv
          do lh=1,ndofEh
            kV=kV+1; jp=0
            NrconV(kV) = ndofEv*ndofEh
            do lpv=1,ndofEv
              do lph=1,ndofEh
                jp=jp+1
                NacV(jp,kV)   =NaV(loc)+(lpv-1)*ndofEh+lph
                ConstrV(jp,kV)=RRRE(1,lph,ish,lh)*RRRE(1,lpv,isv,lv)
              enddo
            enddo
          enddo
        enddo
!
!
!  ...HORIZONTAL MID-EDGE NODE CONSTRAINED BY AN H4-REFINED FACE 
      case(26,28)
!
!       determine horizontal son number
        select case(Icase)
        case(28) ; is=1
        case(26) ; is=2
        end select
!
!       parent mid-face node
        loc=9
!
!       number of parent node horizontal and vertical dof's
        call decode(Nord, nordh,nordv)
        ndofHh=nordh-1 ; ndofEh=nordh
        ndofHv=nordv-1 ; ndofEv=nordv
!
!       number of constrained dof
        ndofH=ndofHh; ndofE = ndofEh
!
!       parent mid-edge nodes (south,north)
        do ip=1,3,2
          locp(ip) = 4+ip
          ndofHp(ip) = nordh-1
          ndofEp(ip) = nordh
        enddo
!
!       H1::loop through the constrained mid-edge node dof
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        do l=1,ndofH
          kH=kH+1
          NrconH(kH) = ndofHh*ndofHv + ndofHp(1) + ndofHp(3)
!
!         loop through the parent mid-face node dof
          jp=0
          do lpv=1,ndofHv
            do lph=1,ndofHh
              jp=jp+1
              NacH(jp,kH)    = NaH(loc)+(lpv-1)*ndofHh+lph
              ConstrH(jp,kH) = RRRH(1,lph,is,l)*RRRH(1,lpv,3,1)
            enddo
          enddo
!
!         loop through the parent mid-edge nodes dofs
          do ip=1,3,2
            do lp=1,ndofHp(ip)
              jp=jp+1
              NacH(jp,kH) = NaH(locp(ip))+lp
              ConstrH(jp,kH)=.5d0*RRRH(1,lp,is,l)
            enddo
          enddo
        enddo
!
!       Hcurl::loop through the constrained mid-edge node dof
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        do l=1,ndofE
          kE=kE+1
          NrconE(kE) = ndofEh*ndofHv + ndofEp(1) + ndofEp(3)
!
!         loop through the parent mid-face node dof
          jp=0
          do lpv=1,ndofHv
            do lph=1,ndofEh
              jp=jp+1
              NacE(jp,kE)    = NaE(loc)+(lpv-1)*ndofEh+lph
              ConstrE(jp,kE) = RRRE(1,lph,is,l)*RRRH(1,lpv,3,1)
            enddo
          enddo
!
!         loop through the parent mid-edge nodes dof
          do ip=1,3,2
            do lp=1,ndofEp(ip)
              jp=jp+1
              NacE(jp,kE) = NaE(locp(ip))+lp
              ConstrE(jp,kE) = .5d0*RRRE(1,lp,is,l)
            enddo
          enddo
        enddo
!
!
!  ...VERTICAL MID-EDGE NODE CONSTRAINED BY AN H4-REFINED FACE
      case(25,27)
!
!       determine vertical son number
        select case(Icase)
        case(25); is=1
        case(27); is=2
        endselect
!
!       parent mid-face node
        loc=9
        call decode(Nord, nordh,nordv)
        ndofHh = nordh-1; ndofEh = nordh
        ndofHv = nordv-1; ndofEv = nordv
!
!       number of constrained dof
        ndofH=ndofHv; ndofE = ndofEv
!
!       parent mid-edge nodes (east,west)
        do ip=2,4,2
          locp(ip)=4+ip
          ndofHp(ip) = nordv-1
          ndofEp(ip) = nordv
        enddo
!
!       H1::loop through the constrained mid-edge node dof
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        do l=1,ndofH
          kH=kH+1
          NrconH(kH) = ndofHh*ndofHv + ndofHp(2) + ndofHp(4)
!
!         loop through the parent mid-face node dofs
          jp=0
          do lpv=1,ndofHv
            do lph=1,ndofHh
              jp=jp+1
              NacH(jp,kH) = NaH(loc)+(lpv-1)*ndofHh+lph
              ConstrH(jp,kH) = RRRH(1,lph,3,1)*RRRH(1,lpv,is,l)
            enddo
          enddo
!
!         loop through the parent mid-edge nodes dof
          do ip=2,4,2
            do lp=1,ndofHp(ip)
              jp=jp+1
              NacH(jp,kH)    = NaH(locp(ip))+lp
              ConstrH(jp,kH)=.5d0*RRRH(1,lp,is,l)
            enddo
          enddo
        enddo
!
!       Hcurl::loop through the constrained mid-edge node dof
!       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        do l=1,ndofE
          kE=kE+1
          NrconE(kE) = ndofHh*ndofEv + ndofEp(2) + ndofEp(4)
!  
!         loop through the parent mid-face node dof
          jp=0
          do lpv=1,ndofEv
            do lph=1,ndofHh
              jp=jp+1
              NacE(jp,kE) = NaE(loc) + ndofEh*ndofHv &
                          + (lpv-1)*ndofHh+lph
              ConstrE(jp,kE) = RRRH(1,lph,3,1)*RRRE(1,lpv,is,l)
            enddo
          enddo
!
!         loop through the parent mid-edge nodes dof
          do ip=2,4,2
            do lp=1,ndofEp(ip)
              jp=jp+1
              NacE(jp,kE) = NaE(locp(ip))+lp
              ConstrE(jp,kE) = .5d0*RRRE(1,lp,is,l)
            enddo
          enddo
        enddo
!
!
!  ...VERTEX NODE CONSTRAINED BY AN H4-REFINED FACE --
      case(29)
!
!       parent mid-face node
        loc=9
        call decode(Nord, nordh,nordv)
        ndofHh = nordh-1
        ndofHv = nordv-1
!
!       parent mid-edge nodes (south,east,north,west)
        do ip=1,4
          locp(ip) = 4+ip
          select case(ip)
          case(1,3); ndofHp(ip) = nordh-1
          case(2,4); ndofHp(ip) = nordv-1
          end select
        enddo
!
!       single H1 dof
        kH=kH+1
        NrconH(kH) = ndofHh*ndofHv  &
                   + ndofHp(1)+ndofHp(2)+ndofHp(3)+ndofHp(4)+4
!
!       loop through the parent mid-face node dof
        jp=0
        do lpv=1,ndofHv
          do lph=1,ndofHh
            jp=jp+1
            NacH(jp,kH)    = NaH(loc)+(lpv-1)*ndofHh+lph
            ConstrH(jp,kH) = RRRH(1,lph,3,1)*RRRH(1,lpv,3,1)
          enddo
        enddo
!
!       loop through the parent mid-edge node dof
        do ip=1,4
          do lp=1,ndofHp(ip)
            jp=jp+1
            NacH(jp,kH)    = NaH(locp(ip))+lp
            ConstrH(jp,kH) = .5d0*RRRH(1,lp,3,1)
          enddo
        enddo
!
!       loop through the parent vertex dof
        do ip=1,4
          loc=ip
          jp=jp+1
          NacH(jp,kH)  = NaH(loc)+1
          ConstrH(jp,kH) = .25d0
        enddo
!
!  ...select Icase
      end select
      if (iprint.eq.1) then
        write(*,*) 'logicPR: kH,kE,kV = ',kH,kE,kV
!        call pause
      endif
!
!
      end subroutine logicPR
!
!-----------------------------------------------------------------------
!     routine allocates data struture arrays for a macroelement edge or 
!     face node
!
!     in:     Type  - node type 
!             Nord  - order of the node
!
!----------------------------------------------------------------------
      subroutine allocate_PR(Type,Nord)
!
      character(len=4) :: Type
      integer :: Nord
!
!  ...locals
      integer :: nordh,nordv,ndofH,ndofE,ndofV,nodl
!
      select case(Type)
      case('medg')
        NORDP = Nord; NORDPH=-1; NORDPV=-1
        NR_NODES_PR = 0
        MAX_NODES_PR = 2**MAXGEN_PR+1
        MDOFH = Nord+1; MDOFE = Nord; MDOFV = 1
      case('mdlq')
        NORDP = Nord; call decode(NORDP, NORDPH,NORDPV)
        NR_NODES_PR = 0
        MAX_NODES_PR = (2**MAXGEN_PR+1)**2
        call decode(Nord, nordh,nordv)
        MDOFH = (nordh+1)*(nordv+1)
        MDOFE = nordh*(nordv+1) + (nordh+1)*nordv
        MDOFV = nordh*nordv
      case default
        write(*,*) 'allocate_Pr; UNFinished';  stop 1
      end select
      allocate(COEFFPH(MDOFH,MDOFH),COEFFPE(MDOFE,MDOFE),&
               COEFFPV(MDOFV,MDOFV),NODES_PR(MAX_NODES_PR))
      do nodl=1,MAX_NODES_PR
        NODES_PR(nodl)%type = 'none'
      enddo
!
      end subroutine allocate_PR
!-----------------------------------------------------------------------
!     routine deallocates data structure arrays for a macro-element edge 
!     or face node
!
!----------------------------------------------------------------------
      subroutine deallocate_PR
!
!  ...locals
      integer :: nodl
!
      do nodl=1,MAX_NODES_PR
        if (allocated(NODES_PR(nodl)%sons))   deallocate(NODES_PR(nodl)%sons)
        if (allocated(NODES_PR(nodl)%coeffH)) deallocate(NODES_PR(nodl)%coeffH)
        if (allocated(NODES_PR(nodl)%coeffE)) deallocate(NODES_PR(nodl)%coeffE)
        if (allocated(NODES_PR(nodl)%coeffV)) deallocate(NODES_PR(nodl)%coeffV)
      enddo
      NORDP = 0
      NR_NODES_PR = 0
      MAX_NODES_PR = 0
      MDOFH = 0; MDOFE = 0; MDOFV = 0
      deallocate(COEFFPH,COEFFPE,COEFFPV,NODES_PR)
!
      end subroutine deallocate_PR
!
!-----------------------------------------------------------------------
!     routine builds the local data structure for an element edge node
!
!     in:     
!         Nodes_edge - edge nodes in the order consistent with the
!                      global orientation
!
!-----------------------------------------------------------------------
      subroutine build_edge_tree(Nodes_edge)
!
      integer :: Nodes_edge(3)
!
!  ...list of nodes to be broken
      integer, parameter:: nlist=100
      integer :: list(nlist)
!
!  ...locals
      integer :: nod,iv,nodl,nord,ic,is,nson,i,nsonl,js,iprint
      integer :: nrdofH, nrdofE, k
!
      iprint=0
      if (iprint.eq.1) then
        write(*,7001) Nodes_edge(1:3)
 7001   format('build_edge_tree:  Nodes_edge = ',3i6)
      endif
      nod = Nodes_edge(3)
      nord = NODES(nod)%orderC
      if (allocated(NODES_PR)) call deallocate_PR
      call allocate_PR(NODES(nod)%type,nord)
!
!  ...store the edge nodes in NODES_PR
      do iv=1,2
        nodl = NR_NODES_PR+1; NR_NODES_PR = nodl
        NODES_PR(nodl)%type = 'vert'
        NODES_PR(nodl)%order = 1
        NODES_PR(nodl)%nod = Nodes_edge(iv)
        NODES_PR(nodl)%ref_kind = 0
        NODES_PR(nodl)%father = -1
        allocate(NODES_PR(nodl)%coeffH(MDOFH,1))
        NODES_PR(nodl)%coeffH = 0.d0; NODES_PR(nodl)%coeffH(iv,1) = 1.d0
      enddo
      nodl = NR_NODES_PR+1; NR_NODES_PR = nodl
      NODES_PR(nodl)%type = 'medg'
      NODES_PR(nodl)%order = NODES(nod)%orderC
      NODES_PR(nodl)%nod = nod
      NODES_PR(nodl)%ref_kind = 0
      NODES_PR(nodl)%father = -1
      allocate(NODES_PR(nodl)%coeffH(MDOFH,nord-1)); NODES_PR(nodl)%coeffH = 0.d0
      allocate(NODES_PR(nodl)%coeffE(MDOFE,nord))  ; NODES_PR(nodl)%coeffE = 0.d0
      nrdofH = nord-1 ; nrdofE = nord 
      do k=1,nrdofH
        NODES_PR(nodl)%coeffH(2+k,k) = 1.d0
      enddo
      do k=1,nrdofE
        NODES_PR(nodl)%coeffE(k,k) = 1.d0
      enddo
!
!  ...initiate list of nodes to refine with the mid-edge node
      ic=0
!
      if (NODES(nod)%ref_kind.ne.0) then
!
!  .....check if sons are active
        do is=1,2
          nson = NODES(nod)%sons(is)
          if (NODES(nson)%act.eq.0 .and. NODES(nson)%ref_kind.eq.0) go to 10
        enddo
        ic=ic+1
        list(ic)=3
      endif
      if (iprint.eq.1) then
        write(*,7003) list(1:ic)
 7003   format('build_edge_tree: Initial LOCAL  list of NODES to refine = ',5i6)
        write(*,7004) Nodes_edge(list(1:ic))
 7004   format('build_edge_tree: Initial GLOBAL list of NODES to refine = ',5i6)
        call pause
      endif

!
 10   continue
      i=0
      do while(i+1.le.ic)
        i=i+1
        nodl = list(i)
!
!  .....break the node from the list
        call nodbreakPR(nodl)
!
!  .....update the list
        do is=1,2
          nsonl = NODES_PR(nodl)%sons(is)
          nod = NODES_PR(nsonl)%nod
          if (NODES(nod)%ref_kind.ne.0) then
!
!  .........check if sons are active
            do js=1,2
              nson = NODES(nod)%sons(js)
              if (NODES(nson)%act.eq.0) go to 20
            enddo
            ic=ic+1
            if (ic.gt.nlist) then
              write(*,*) 'build_edge_tree: INCREASE nlist'
              stop 1
            endif
            list(ic) = nsonl
          endif
 20       continue
        enddo
      enddo
!
      end subroutine build_edge_tree
!
!-----------------------------------------------------------------------
!     routine builds the local data structure for a coarse mesh element
!     face node
!
!     in: 
!         Type         - face nod type
!         Nordf        - face order    
!         Nodes_face   - nodes on the face using global orientation
!
!-----------------------------------------------------------------------
      subroutine build_face_tree(Type,Nordf,Nfedg_or,Nodes_face)
!
      character(len=4) :: Type
      integer :: Nordf,Nfedg_or(4),Nodes_face(9)
!
!  ...list of nodes to be broken
      integer, parameter :: nlist=100
      integer :: list(nlist)
!
!  ...locals
      integer :: nod,i,j,iv,ie,nodl,nord,nordh,nordv,ic,is,nson,nsonl,&
                 ndofH,ndofE,ndofV,ndofQ,nrsons,nrsonsl,js,iprint,nrfn,k, &
                 nrv,nre,ndofHt,ndofEt
!
      iprint=0
      nrv = nvert(Type); nre = nedge(Type); nrfn = nrv + nre + 1
      if (iprint.eq.1) then
        write(*,7002) Type,Nordf,Nodes_face(1:nrfn)
 7002   format('build_face_tree: Type,Nordf,Face nodes list = ',a4,i3,2x,9i6)
      endif
!
      if (allocated(NODES_PR)) call deallocate_PR
      call allocate_PR(Type,Nordf)
!
!  ...store the face  nodes in NODES_PR
      do iv=1,nrv   !  vertices
        nodl = NR_NODES_PR+1; NR_NODES_PR = nodl
        NODES_PR(nodl)%type = 'vert'
        NODES_PR(nodl)%order = 1
        NODES_PR(nodl)%nod = Nodes_face(iv)
        NODES_PR(nodl)%ref_kind = 0
        NODES_PR(nodl)%father = -1
        allocate(NODES_PR(nodl)%coeffH(MDOFH,1)) 
        NODES_PR(nodl)%coeffH = 0.d0; NODES_PR(nodl)%coeffH(iv,1) = 1.d0
      enddo
      ndofHt=nrv; ndofEt=0
      do ie=1,nre  ! edges
        nodl = NR_NODES_PR+1; NR_NODES_PR = nodl
        NODES_PR(nodl)%type = 'medg'
        NODES_PR(nodl)%nod = Nodes_face(nvert(Type)+ie)
        select case(Type)
        case('mdlt'); nord = NORDP
        case('mdlq')
          select case(ie)
          case(1,3); nord = NORDPH
          case(2,4); nord = NORDPV
          end select
        end select
        NODES_PR(nodl)%order = nord
        NODES_PR(nodl)%ref_kind = 0
        NODES_PR(nodl)%father = -1
        ndofH = nord-1 ; ndofE = nord
        allocate(NODES_PR(nodl)%coeffH(MDOFH,ndofH)) ; NODES_PR(nodl)%coeffH = 0.d0
        allocate(NODES_PR(nodl)%coeffE(MDOFE,ndofE)) ; NODES_PR(nodl)%coeffE = 0.d0
        select case(Nfedg_or(ie))
        case(0)
          do k=1,ndofH
            NODES_PR(nodl)%coeffH(ndofHt+k,k) = 1.d0
          enddo
          do k=1,ndofE
            NODES_PR(nodl)%coeffE(ndofEt+k,k) = 1.d0
          enddo
        case(1)
          do k=1,ndofH
            NODES_PR(nodl)%coeffH(ndofHt+k,k) = (-1.d0)**(k+1)
          enddo
          do k=1,ndofE
            NODES_PR(nodl)%coeffE(ndofEt+k,k) = (-1.d0)**k
          enddo
        end select
        ndofHt = ndofHt + ndofH; ndofEt = ndofEt + ndofE
      enddo
!
!  ...middle node
      nodl = NR_NODES_PR+1; NR_NODES_PR = nodl
      NODES_PR(nodl)%type = Type
      NODES_PR(nodl)%order = NORDP
      nod = Nodes_face(nvert(Type)+nedge(Type)+1)
      NODES_PR(nodl)%nod = nod
      NODES_PR(nodl)%ref_kind = 0
      NODES_PR(nodl)%father = -1
      call ndof_nod(Type,NORDP, ndofH,ndofE,ndofV,ndofQ)
      allocate(NODES_PR(nodl)%coeffH(MDOFH,ndofH)) ; NODES_PR(nodl)%coeffH = 0.d0 
      allocate(NODES_PR(nodl)%coeffE(MDOFE,ndofE)) ; NODES_PR(nodl)%coeffE = 0.d0
      allocate(NODES_PR(nodl)%coeffV(MDOFV,ndofV)) ; NODES_PR(nodl)%coeffV = 0.d0
      do k=1,ndofH
        NODES_PR(nodl)%coeffH(ndofHt+k,k) = 1.d0
      enddo
      do k=1,ndofE
        NODES_PR(nodl)%coeffE(ndofEt+k,k) = 1.d0
      enddo
      do k=1,ndofV
        NODES_PR(nodl)%coeffV(k,k) = 1.d0
      enddo
!
!  ...initiate list of nodes to refine with the higher order nodes
!     on the face
      ic=0
      do nodl=nvert(Type)+1,nvert(Type)+nedge(Type)+1
        nod = NODES_PR(nodl)%nod
        if (NODES(nod)%ref_kind.ne.0) then
          call find_nsons(nod, nrsons)
!
!  .......check if sons are active
          do is=1,nrsons
            nson = NODES(nod)%sons(is)
            if (NODES(nson)%act.eq.0 .and. NODES(nson)%ref_kind.eq.0) go to 10
          enddo
          ic=ic+1
          list(ic)=nodl
        endif
 10     continue
      enddo
      if (iprint.eq.1) then
        write(*,7003) list(1:ic)
 7003   format(' build_face_tree: Initial LOCAL  list of NODES to refine = ',5i6)
        write(*,7004) Nodes_face(list(1:ic))
 7004   format(' build_face_tree: Initial GLOBAL list of NODES to refine = ',5i6)
        call pause
      endif
!
      i=0
      do while(i+1.le.ic)
        i=i+1
        nodl = list(i)
!
!  .....break the node from the list
        call nodbreakPR(nodl)
        nrsonsl = ubound(NODES_PR(nodl)%sons,1)
!
!  .....update the list
        do is=1,nrsonsl
          nsonl = NODES_PR(nodl)%sons(is)
          nod = NODES_PR(nsonl)%nod
          if (NODES(nod)%ref_kind.ne.0) then
            call find_nsons(nod, nrsons)
!
!  .........check if sons are active
            do js=1,nrsons
              nson = NODES(nod)%sons(js)
              if (NODES(nson)%act.eq.0) go to 20
            enddo
            ic=ic+1
            if (ic.gt.nlist) then
              write(*,*) 'build_face_tree: INCREASE nlist'
              stop 1
            endif
            list(ic) = nsonl
          endif
 20       continue
        enddo
      enddo
!
      end subroutine build_face_tree
!
!  ...returns the information whether the node is in the interior
!     of the face
      function Face_interior_node(Nodl)
!        
      integer :: Nodl,nson,nfath
      logical :: Face_interior_node
!
!  ...loop through ancestors
      nson = Nodl
      nfath = NODES_PR(nson)%father
      do while(nfath.gt.0)
        nson = nfath
        nfath = NODES_PR(nson)%father
      enddo
      select case(NODES_PR(nson)%type)
      case('mdlt','mdlq')
         Face_interior_node = .TRUE. 
      case default
         Face_interior_node = .false.
      end select

!
      end function Face_interior_node
!
!

!  ...returns the information whether the node is in the interior
!     of the face
      function Edge_interior_node(Nodl)
!        
      integer :: Nodl,nson,nfath
      logical :: Edge_interior_node
!
!  ...loop through ancestors
      nson = Nodl
      nfath = NODES_PR(nson)%father
      do while(nfath.gt.0)
        nson = nfath
        nfath = NODES_PR(nson)%father
      enddo
      select case(NODES_PR(nson)%type)
      case('medg')
         Edge_interior_node = .TRUE. 
      case default
         Edge_interior_node = .false.
      end select

!
      end function Edge_interior_node

      end module prolongation




