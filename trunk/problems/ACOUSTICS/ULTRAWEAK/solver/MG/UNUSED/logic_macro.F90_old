! -----------------------------------------------------------------------
!
!    routine name      - logic_macro
!
! -----------------------------------------------------------------------
!
!    latest revision   - Jan 2018
!
!    purpose           - routine establishes dof connectivities
!                        between a macro-element and the corresponding
!                        coarse grid element
!
!   arguments :
!     in:
!           MdleC      - middle node of a coarse element
!           Nod_macro  - macro-element nodes
!           Nr_macro   - # of macro-element nodes
!             Nrdofm   - Number of dof in the macro-element
!             Nrnodm   - Number of nodes in the macro-element
!             Nodm     - List of macro-element nodes
!             NdofHm   - Number of H1 dof of the macro-element node
!             NdofEm   - Number of H(curl) dof of the macro-element node
!             NdofVm   - Number of H(div) dof of the macro-element node
!     out:     
!           Nodm       - nodes of the modified coarse grid element
!                        excluding the middle node
!           NdofmH,NdofmE,NdofmV - the corresponding number of
!                        H1, H(curl),H(div) single component dof
!           Nrnodm     - number of modified coarse grid element nodes
!
! ----------------------------------------------------------------------
!
   subroutine logic_macro(MdleC,&
                          Nod_macro,Nr_macro, &
                          Nodm,NdofmH,NdofmE,NdofmV,Nrnodm, &
Nrdofm, Nrnodm, Nodm,NdofHm, NdofEm, NdofVm)
!
   use data_structure3D
   use refinements
   use prolongation

   IMPLICIT NONE

   integer, intent(in)  :: MdleC,Nod_macro(Nr_macro),Nr_macro
   integer, intent(out) :: Nrnodm,Nodm(Nrnodm), &
                           NdofHm(Nrnodm), NdofEm(Nrnodm), NdofVm(Nrnodm)

!..element type
   character(len=4)    :: type, facetype
   integer             :: nodesl(27),norientl(27),norder(19)
   integer             :: nodc(MAXNODM),nrnodc
   integer             :: i,  medg, iedg(2), nodes_edge(3)
   integer             :: if, mface, ivf(4),ief(4), nodes_face(9)
   integer             :: nod, nord, nordh, nordv,j,ie,iv
   integer             :: nrv, nre, nrf, nrvf
   integer             :: iprint,nrfn

   integer :: icH,icE,icV,im,nvoid, &
              nrdofH_macro,nrdofE_macro,nrdofV_macro &
              
!
!..offsets for first dof for modified coarse element nodes
   dimension naH(MAXNODM),naE(MAXNODM),naV(MAXNODM)
!
!..offsets for first dof for macroelement element nodes
   dimension naHC(MAXmacro),naEC(MAXmacro),naVC(MAXmacro)


   iprint = 0
!      
!
!..get element nodes and build the local data base on constrained
!..nodes for the element
   call get_connect_infoC(MdleC, nodesl,norientl)
!
!..get nodes of the modified coarse element
   call logic_nodesC(MdleC,nodesl, Nodm,Nrnodm) 
!
!..remove the middle node from the list
   Nodm(Nrnodm) = 0; Nrnodm = Nrnodm-1
!
!..establish offsets for the modified coarse element nodal dof 
!  USING THE REVERSE ORDER
   icH=0; icE=0; icV=0
   do im = Nrnodm,1,-1
      naH(im)=icH; naE(im)=icE; naV(im)=icV
      nod = Nodm(im)
      call ndof_nod(NODES(nod)%type,NODES(nod)%orderC, &
                    NdofmH(im),NdofmE(im),NdofmV(im),nvoid)
      icH=icH+NdofmH(im); icE=icE+NdofmE(im); icV=icV+NdofmV(im)
   enddo
!
   if (iprint.eq.1) then
      write(*,7001) MdleC
 7001 format('logic_macro: MODIFIED ELEMENT NODES FOR MdleC = ',i6)
      do im = Nrnodm,1,-1
         nod = Nodm(im)
         write(*,7002) im,nod,NODES(nod)%type,NODES(nod)%order, &
                       naH(im),NdofmH(im), &
                       naE(im),NdofmE(im), &
                       naV(im),NdofmV(im)
 7002 format(' im  = ',i3,' nod = ',i6,' TYPE = ',a6,' ORDER = ',i3, &
             ' naH = ',i3,' NdofmH = ',i3, &
             ' naE = ',i3,' NdofmE = ',i3, &
             ' naV = ',i3,' NdofmV = ',i3)
      enddo
   endif
!
!..establish offsets for the macro-element nodal dof
   icH=0; icE=0; icV=0
   do im=1,Nr_macro
      naHC(im)=icH; naEC(im)=icE; naVC(im)=icV
      nod = Nod_macro(im)
      call ndof_nod(NODES(nod)%type,NODES(nod)%order,  &
                    NdofH_macro(im),NdofE_macro(im),NdofV_macro(im),nvoid)
      icH=icH+NdofH_macro(im); icE=icE+NdofE_macro(im); icV=icV+NdofV_macro(im)
   enddo
   nrdofH_macro = icH; nrdofE_macro = icE; nrdofV_macro = icV
   if (iprint.eq.1) then
      write(*,8012) MdleC
 8012 format('logic_macro: MACRO-ELEMENT NODES FOR MdleC = ',i6)
      do im=1,Nrm
         nod = Nod_macro(im)
         write(*,7002) im,nod,NODES(nod)%type,NODES(nod)%order, &
                       naHC(im),NdofH_macro(im), &
                       naEC(im),NdofE_macro(im), &
                       naVC(im),NdofV_macro(im)
      enddo
      call pause
   endif
!
!-----------------------------------------------------------------------
!
!..initiate the connectivities arrays
   NrconH = 0; NacH = 0; ConstrH = 0.d0
   NrconE = 0; NacE = 0; ConstrE = 0.d0
   NrconV = 0; NacV = 0; ConstrV = 0.d0
!
!..coarse grid element nodes first
   do im= Nrnodm,1,-1
      nod = Nodm(im)
      call locate (nod, Nod_macro,Nrm, loc)
      if (loc.ne.0) then
         kH = naHC(loc); kE = naEC(loc)
         do j=1,NdofmH(im)
            NrconH(kH+j)=1
            NacH(1,kH+j) = naH(im)+j
            ConstrH(1,kH+j) = 1.d0
         enddo
         do j=1,NdofmE(im)
            NrconE(kE+j) = 1
            NacE(1,kE+j) = naE(im)+j
            ConstrE(1,kE+j) = 1.d0
         enddo
         do j=1,NdofmV(im)
            NrconV(kV+j) = 1
            NacV(1,kV+j) = naV(im)+j
            ConstrV(1,kV+j) = 1.d0
         enddo
!
!     ...there may be excess dof due to p-refinement, they are not
!        connected
         do j=NdofmH(im)+1,NdofH_macro(loc)
            NrconH(kH+j)=0
         enddo
         do j=NdofmE(im)+1,NdofE_macro(loc)
            NrconE(kE+j)=0
         enddo
         do j=NdofmV(im)+1,NdofV_macro(loc)
            NrconV(kV+j)=0
         enddo
      endif
   enddo
!
!
!-----------------------------------------------------------------------
!
   type = NODES(MdleC)%type
   nrv = nvert(type); nre = nedge(type); nrf = nface(type)
!
!..loop through the macroelement edges
   do ie=1,nre
!
!  ...local mid-edge node number
      i = nrv + ie
      medg = nodesl(i)      
!
!  ...pick up the edge vertex nodes in the order determined by the
!  ...edge orientation
      call edge_to_vert(type,ie, iedg(1),iedg(2))
      if (norientl(i).eq. 1) call swap(iedg(1),iedg(2))
      nodes_edge(1:2) = nodesl(iedg(1:2))
      nodes_edge(3) = medg
!
      call build_edge_tree(nodes_edge)
      if (iprint .eq. 1) call print_nodesPR
!
!  ...loop through nodes in the tree
      do nodC=1,NR_NODES_PR
!
!     ...global node number
         nod = NODES_PR(nodC)%nod
         call locate(nod,Nod_macro,Nrm, loc)
!
!     ...skip if not on the list of macro-element nodes
         if (loc.eq.0) cycle
         ndofHC = NdofH_macro(loc)
         ndofEC = NdofE_macro(loc)
         ndofVC = NdofV_macro(loc) 
!
!     ...skip if the node has already been considered in the first step
!     ...of the algorithm (i.e., it is common to both coarse-grid element
!     ...and the macro-element)
         call locate(nod,Nodm,Nrnodm, loc1)
         if (loc1.ne.0) cycle
!
         select case(NODES(nod)%type)
         case('vert')
            kH=naHC(loc)+1; constrH(1:NACDIM,kH) = 0.d0
            nH=0
!
            if (allocated(NODES_PR(nodC)%coeffH)) then
!
!           ...loop through parent vertex nodes
               do jv=1,2
                  nodp = nodesl(iedg(jv))
                  if (NODES(nodp)%master.eq.1) then
                     call add_dof(nodp,1,Nodm,Nrnodm,naH, &
                          NacH(1:NACDIM,kH),ConstrH(1:NACDIM,kH),nH, &
                          NODES_PR(nodC)%coeffH(1,jv))
                  else
                     call decode2(NODES_CONSTR(iedg(jv)), nc,icase)
                     do jjv=1,2
                        nodpp = NEDG_CONS(jjv,nc)
                        if (NODES(nodpp)%master.ne.1) stop 3
                        call add_dof(nodpp,1,Nodm,Nrnodm,naH, &
                             NacH(1:NACDIM,kH),ConstrH(1:NACDIM,kH),nH, &
                             NODES_PR(nodC)%coeffH(1,jv)*.5d0)
                     enddo
                     nodpp = NEDGC(nc)
                     if (NODES(nodpp)%master.ne.1) stop 3
                     call ndof_nod(NODES(nodpp)%type, &
                     NODES(nodpp)%orderC,ndofH,ndofE,nvoid,nvoid)
                     do l=1,ndofH
                        call add_dof(nodpp,l,Nodm,Nrnodm,naH, &
                        NacH(1:NACDIM,kH),ConstrH(1:NACDIM,kH),nH, &
                        NODES_PR(nodC)%coeffH(1,jv)*RRR(3,l,1,1))
                     enddo
                  endif
               enddo
!
!           ...mid-edge parent node
               nodp = medg
               if (NODES(nodp)%master.eq.1) then
                  call ndof_nod(NODES(nodp)%type,NODES(nodp)%orderC,  &
                             ndofH,ndofE,nvoid,nvoid)
                  do lp=1,ndofH
                     call add_dof(nodp,lp,Nodm,Nrnodm,naH, &
                          NacH(1:NACDIM,kH),ConstrH(1:NACDIM,kH),nH, &
                          NODES_PR(nodC)%coeffH(1,2+lp))
                  enddo
               else
                  call decode2(NODES_CONSTR(i), nc,icase)
                  call decode(icase, nvoid,nos)
                  nodpp = NEDGC(nc)
                  call ndof_nod(NODES(nodpp)%type,NODES(nodpp)%orderC,  &
                             ndofH,ndofE,nvoid,nvoid)
                  if (NODES(nodpp)%master.ne.1) stop 3
                  do lpp=1,ndofH
                     do lp=1,ndofH
                        call add_dof(nodpp,lpp,Nodm,Nrnodm,naH, &
                             NacH(1:NACDIM,kH),ConstrH(1:NACDIM,kH), &
                             nH,NODES_PR(nodC)%coeffH(1,2+lp)* &
                             RRR(3,lpp,1+nos,lp))
                     enddo
                  enddo
               endif
               NrconH(kH) = nH
            endif
!        ...mid-edge node
         case('medg')
!        ...mid-edge parent node
            nodp = medg
            if (NODES(nodp)%master.eq.1) then
               call ndof_nod(NODES(nodp)%type,NODES(nodp)%orderC, &
                          ndofH,ndofE,nvoid,nvoid)
! 
               if (allocated(NODES_PR(nodC)%coeffH)) then
                  do l=1,ndofH
                     kH=naHC(loc)+l 
                     constrH(1:NACDIM,kH) = 0.d0 ; nH=0
                     do lp=1,ndofH
                        call add_dof(nodp,lp,Nodm,Nrnodm,naH, &
                             NacH(1:NACDIM,kH),ConstrH(1:NACDIM,kH),nH, &
                             NODES_PR(nodC)%coeffH(l,2+lp))
                     enddo
                     NrconH(kH) = nH
                  enddo
               endif
               if (allocated(NODES_PR(nodC)%coeffE)) then
                  do l=1,ndofE
                     kE=naEC(loc)+l
                     constrE(1:NACDIM,kE) = 0.d0 ; nE=0
                     do lp=1,ndofE
                        call add_dof(nodp,lp,Nodm,Nrnodm,naE, &
                             NacE(1:NACDIM,kE),ConstrE(1:NACDIM,kE),nE, &
                             NODES_PR(nodC)%coeffE(l,lp))
                     enddo
                     NrconE(kE) = nE
                  enddo
               endif
            else
               call decode2(NODES_CONSTR(i), nc,icase)
               call decode(icase, nvoid,nos)
               nodpp = NEDGC(nc)
               if (NODES(nodpp)%master.ne.1) stop 3
               call ndof_nod(NODES(nodpp)%type,NODES(nodpp)%orderC, &
                             ndofH,ndofE,nvoid,nvoid)               
               if (allocated(NODES_PR(nodC)%coeffH)) then 
                  do l=1,ndofH
                     kH=naHC(loc)+l
                     constrH(1:NACDIM,kH) = 0.d0 ; nH=0
                     do lpp=1,ndofH
                        do lp=1,ndofH
                          call add_dof(nodpp,lpp,Nodm,Nrnodm,naH, &
                                NacH(1:NACDIM,kH),ConstrH(1:NACDIM,kH), &
                                nH,NODES_PR(nodC)%coeffH(l,2+lp)* &
                                RRR(3,lpp,1+nos,lp))
                        enddo
                     enddo
                     NrconH(kH) = nH
                  enddo
               endif
               if (allocated(NODES_PR(nodC)%coeffE)) then
                  do l=1,ndofE
                     kE=naEC(loc)+l
                     constrE(1:NACDIM,kE) = 0.d0 ; nE=0
                     do lpp=1,ndofE
                        do lp=1,ndofE
                           call add_dof(nodpp,lpp,Nodm,Nrnodm,naE, &
                                NacE(1:NACDIM,kE),ConstrE(1:NACDIM,kE),nE, &
                                NODES_PR(nodC)%coeffE(l,lp)* &
                                RRRE(1,lpp,nos,lp)) 
                        enddo
                     enddo
                     NrconE(kE) = nE
                  enddo
               endif
            endif
!
!        ...higher order dof are not connected
            do l=ndofH+1,ndofHC
               kH=kH+1
               NrconH(kH)=0
            enddo
            do l=ndofE+1,ndofEC
               kE=kE+1
               NrconE(kE)=0
            enddo
         end select  
!     ...end of loop through nodes in the tree
      enddo
!..end of loop through edges
   enddo
!
   if (iprint.ge.2) then
      write(*,7011) MdleC
 7011 format('logic: MdleC = ',i6)
      do i=1,Nrm
         nod = Nod_macro(i)
         write(*,7012) i,nod
 7012 format('logicC: i = ',i3,' nod = ',i5)
         do j=1,NdofH_macro(i)
            kH = naHC(i)+j
            write(*,7013) kH,NrconH(kH)
 7013 format('logicC: kH = ',i4,' NrconH = ',i3)
            write(*,7014) NacH(1:NrconH(kH),kH)
 7014 format(20i6)
            write(*,7015) ConstrH(1:NrconH(kH),kH)
 7015 format(20f6.3)
         enddo
         do j=1,NdofE_macro(i)
            kE = naEC(i)+j
            write(*,7022) kE,NrconE(kE)
 7022 format('logicC: kE = ',i4,' NrconE = ',i3)
            write(*,7023) NacE(1:NrconE(kE),kE)
 7023 format(20i6)
            write(*,7024) ConstrE(1:NrconE(kE),kE)
 7024 format(20f6.3)
         enddo
      enddo
      call pause
   endif
!














































   enddo

!..build local tree for faces
   do if=1,nrf
!
!  ...number of vertices on the face (3 or 4)
      nrvf = nvert(facetype(type,if))
!
!  ...pick up the local face nodes numbers
      call face_nodes(type,if, nodes_face,nrfn)
!
!  ...loop through face vertices and edges
      do j=1,nrvf
!
!  .....local vertex and edge number consistent with orientation
         select case(facetype(type,if))
         case('mdlt'); iv = TRIAN_L2G(j,norientl(nrv+nre+if))
         case('mdlq'); iv = QUADR_L2G(j,norientl(nrv+nre+if))
         end select
         ie=nrvf+iv
         nodes_face(j) = nodesl(nodes_face(iv))
         nodes_face(nrvf+j) = nodesl(nodes_face(ie))
      enddo
      nodes_face(nrvf+nrvf+1) = nodesl(nrv+nre+if)
!
!  ...determine the face order for the prolongation operator
      nod = nodesl(nrv+nre+if)
      select case(facetype(type,if))
      case('mdlt')
         nord = NODES(nod)%order
         do ie=1,3
            nod = nodes_face(3+ie)
            nord = max(nord,NODES(nod)%order)
         enddo
      case('mdlq')
         call decode(NODES(nod)%order, nordh,nordv)
         do ie=1,3,2
            nod = nodes_face(4+ie)
            nordh = max(nordh,NODES(nod)%order)
         enddo
         do ie=2,4,2
            nod = nodes_face(4+ie)
            nordv = max(nordv,NODES(nod)%order)
         enddo
         nord = nordh*10+nordv
      end select
!
      call build_face_tree(facetype(type,if),nord,nodes_face)
      ! if (iprint .eq. 2) call print_nodesPR
   enddo      

   end subroutine logic_macro


! -----------------------------------------------------------------------
!
!    routine name      - print_nodesPR
!
! -----------------------------------------------------------------------
!
!    latest revision   - Jan 2018
!
!    purpose           - 
!
!   arguments :
!
! ----------------------------------------------------------------------
!

   subroutine print_nodesPR
!
   use prolongation

   implicit none 

   integer :: i, nrs,j, sonl(9), iH, jH, iE, jE, iV, jV, temp(2)


!..print out NODES_PR
   do i=1,NR_NODES_PR
      write (*,6001) i,NODES_PR(i)%type,NODES_PR(i)%nod,       &
                       NODES_PR(i)%ref_kind,NODES_PR(i)%father
 6001 format('  i     = ',i4,'    type = ',a4,'    nod = ',i5,     &
                      '    ref_kind = ',i2,'    father = ',i4)
!
 !      if (NODES_PR(i)%ref_kind .ne. 0) then
 !         call nr_sons(NODES_PR(i)%type,NODES_PR(i)%ref_kind, nrs)
 !         write(*,6002) NODES_PR(i)%sons(1:nrs)
 ! 6002    format('sons      = ',9i6)
 !         write(*,6003) NODES_PR(NODES_PR(i)%sons(1:nrs))%nod
 ! 6003    format('sons nod  = ',9i6)
 !         write(*,*)
 !      endif

      temp =  ubound(NODES_PR(i)%coeffH); iH = temp(1); jH = temp(2)
      temp =  ubound(NODES_PR(i)%coeffE); iE = temp(1); jE = temp(2) 
      temp =  ubound(NODES_PR(i)%coeffV); iV = temp(1); jV = temp(2)
! 
      do j = 1, jH
         write(*,6004) j, NODES_PR(i)%coeffH(1:iH,j)
 6004    format(' jH     = ', i4,/,' coeffH = ', 5e13.4,/,5(10x,5e13.4,/))
      enddo        
      do j = 1, jE
         write(*,6005) j, NODES_PR(i)%coeffE(1:iE,j)
 6005    format(' jE     = ', i4,/,' coeffE = ', 5e13.4,/,5(10x,5e13.4,/))
      enddo
      do j = 1, jV
         write(*,6006) j, NODES_PR(i)%coeffV(1:iV,j)
 6006    format(' jV     = ', i4,/,' coeffV = ', 5e13.4,/,5(10x,5e13.4,/))
      enddo
      write(*,*)
      call pause
   enddo
!
!
   end subroutine print_nodesPR




   function Facetype(Type,If)
!
   character(len=4) :: Facetype,Type
!
   select case(Type)
   case('mdlp')
      select case(If)
      case(1,2);   Facetype = 'mdlt'
      case(3,4,5); Facetype = 'mdlq'
      end select
   case('mdlb')
      Facetype = 'mdlq'
   case('mdln')
      Facetype = 'mdlt'
   case('mdld')
      select case(If)
      case(1); Facetype = 'mdlq'
      case(2,3,4,5); Facetype = 'mdlt'
      end select
   end select
   end function Facetype
