!----------------------------------------------------------------------------------------------
!> Purpose : update the dirichle BC on the edge performing H1 projection
!!
!! @param[in]  Iflag        - a flag specifying which of the objects
!!                            5 pris, 6 hexa, 7 tetr, 8 pyra
!! @param[in]  No           - number of a specific object 
!! @param[in]  Etav         - reference coordinates of the element vertices
!! @param[in]  Type         - element (middle node) type
!! @param[in]  Icase        - the mid-edge node case
!! @param[in]  Nedge_orient - edge orientation (not needed really)
!! @param[in]  Nface_orient - face orientation (not needed really)
!! @param[in]  Norder       - element order
!! @param[in]  Iedg         - edge number 
!! @param[in]  ZdofH        - H1 dof for the element (vertex values really)
!! 
!! @param[out] ZnodH        - H1 dof for the edge
!!
!> @date Jan 15
!----------------------------------------------------------------------------------------------
!
#include "implicit_none.h"
!
subroutine dhpedgeH(Mdle,Iflag,No,Etav,Type,Icase,Nedge_orient,Nface_orient,Norder,Iedg,ZdofH, ZnodH)
!
      use control
      use parameters
      use physics
      use element_data
!      
      implicit none
      integer,                                    intent(in)  :: Iflag,No,Mdle
      integer,                                    intent(in)  :: Icase,Iedg
      real*8,  dimension(3,8),                    intent(in)  :: Etav
      character(len=4),                           intent(in)  :: Type
      integer, dimension(12),                     intent(in)  :: Nedge_orient
      integer, dimension(6),                      intent(in)  :: Nface_orient
      integer, dimension(19),                     intent(in)  :: Norder
      VTYPE,   dimension(MAXEQNH,MAXbrickH),      intent(in)  :: ZdofH
      VTYPE,   dimension(NRCOMS*NREQNH(Icase),*), intent(out) :: ZnodH
!
      integer, dimension(19)          :: norder_1
      real*8,  dimension(MAXbrickH)   ::  shapH
      real*8,  dimension(3,MAXbrickH) :: dshapH
      real*8,  dimension(3)           :: xi, eta, x, dxdt, dxidt
      real*8,  dimension(3,3)         :: dxdxi,dxdeta,detadxi
      real*8,  dimension(MAXP-1)      :: shapH_edge,dshapH_edge
!
!     Dirichlet BC data at a point and its Piola transformations
      VTYPE :: zvalH  (MAXEQNH),zdvalH(  MAXEQNH,3),zdvalHdxi(MAXEQNH,3),zdvalHdt(MAXEQNH), &
               zvalE(3,MAXEQNE),zdvalE(3,MAXEQNE,3),                                        & 
               zvalV(3,MAXEQNV),zdvalV(3,MAXEQNV,3)
!    
!     case indicating physical attributes supported by the node
      integer, dimension(NR_PHYSA) :: ncase
!    
!     projection matrix and pivots (to be potentially reused at next call)
      real*8,  dimension(MAXP-1,MAXP-1), save :: aaH
      integer, dimension(MAXP-1)       , save :: ipivH
!    
!     load vector
      VTYPE,  dimension(MAXP-1,MAXEQNH) :: zbH,zuH
      real*8, dimension(MAXP-1,MAXEQNH) :: duH_real,duH_imag
    
      integer :: &
           i,j,k,l,ii,ivarH,nvarH,naH,iprint, info, &
           nint, ndofH_edge,ndofE_edge,ndofV_edge,ndofQ_edge, &
           nrdofH, nord
      real*8,  dimension(MAXP+1)         :: xi_list, wa_list 
      real*8                             :: t, wa
!    
!     order of previously calculated projection
      integer, save :: nord_old=0
!      
!----------------------------------------------------------------------
!     
!     printing flag
      iprint=1 
!
!     edge order of approximation
      nord = Norder(Iedg)
!
!     if needed, clear (real-valued) projection matrix
      if (nord /= nord_old) then 
        aaH=0.d0
      endif
!    
!     initialize (possibly complex-valued) load vector 
      zbH=ZERO
!
!     number of edge dof's
      call ndof_nod('medg',nord, ndofH_edge,ndofE_edge,ndofV_edge,ndofQ_edge)
!
!     if no H1 dof's associated to edge, return
      if (ndofH_edge == 0) then
        return
      endif
!    
!     initiate element order to 1st order
      call initiate_order(Type, norder_1)
!
!     1D integration rule
  INTEGRATION=1   ! overintegrate
      call set_1Dint(nord, nint, xi_list, wa_list)
  INTEGRATION=0   ! reset
!    
!     loop over integration points
      do l=1,nint
!
!       Gauss point and weight
        t  = xi_list(l)
        wa = wa_list(l)
!    
!       determine edge parameterization for line integral
        call edge_param(Type,Iedg,t, xi,dxidt)
!
!       printing
        if (iprint.eq.1) then
          write(*,8000) l,t
 8000     format(' dhpedgeH: INTEGRATION POINT            = ',i3,e12.5)
          write(*,8001) xi(1:3),dxidt(1:3)
 8001     format(' dhpedgeH: EDGE PARAMETERATION xi,dxidt = ',3f8.3,2x,3f8.3)
        endif
!    
!       element vertex shape functions
        call shape3H(Type,xi,norder_1,Nedge_orient,Nface_orient, nrdofH,shapH,dshapH)
!
!       MASTER --> REFERENCE : Eta = Eta(Xi)
        eta(1:3)=0.d0 ; detadxi(1:3,1:3)=0.d0 
        do k=1,nrdofH
          eta(1:3) = eta(1:3) + Etav(1:3,k)*shapH(k)
          do i=1,3
            detadxi(1:3,i) = detadxi(1:3,i) + Etav(1:3,k)*dshapH(i,k)
          enddo
        enddo
!    
!       REFERENCE --> PHYSICAL : X = X(Eta)
        select case(Iflag)
        case(5) ; call prism(No,eta, x,dxdeta)
        case(6) ; call  hexa(No,eta, x,dxdeta)
        case(7) ; call tetra(No,eta, x,dxdeta)
        case(8) ; call pyram(No,eta, x,dxdeta)
        case default
          write(*,*) 'dhpedgeH: Type = ', Type
          call logic_error(ERR_INVALID_VALUE,__FILE__,__LINE__)
        endselect
!    
!       evaluate geometry map derivative dX/dXi
        dxdxi(1:3,1:3)=0.d0
        do i=1,3
          do j=1,3
            dxdxi(1:3,i) = dxdxi(1:3,i) + dxdeta(1:3,j)*detadxi(j,i)
          enddo
        enddo
 
!       evaluate the Dirichlet data (this is an application-specific routine)
        call dirichlet(Mdle,x,Icase, zvalH,zdvalH,zvalE,zdvalE,zvalV,zdvalV)
!        
!       derivatives of Dirichlet data wrt master coordinates
        zdvalHdxi(1:MAXEQNH,1:3)=ZERO
        do i=1,3
          do j=1,3
            zdvalHdxi(1:MAXEQNH,i) = zdvalHdxi(1:MAXEQNH,i) + zdvalH(1:MAXEQNH,j)*dxdxi(j,i)
          enddo
        enddo
! 
!       subtract the contribution from vertices
        do k=1,nrdofH
          do i=1,3
            zdvalHdxi(1:MAXEQNH,i) = zdvalHdxi(1:MAXEQNH,i) - ZdofH(1:MAXEQNH,k)*dshapH(i,k)
          enddo
        enddo
!    
!       evalute derivative wrt edge coordinate
        zdvalHdt(1:MAXEQNH)=ZERO
        do i=1,3
           zdvalHdt(1:MAXEQNH) = zdvalHdt(1:MAXEQNH) + zdvalHdxi(1:MAXEQNH,i)*dxidt(i)
        enddo
!    
!       1D H1-bubbles
        call shapHbe(t,nord,Nedge_orient(Iedg), ndofH_edge,shapH_edge,dshapH_edge)
!        
!       1st loop over 1D H1-bubbles
        do j=1,ndofH_edge
!
!         LOAD VECTOR for projection (possibly complex-valued)
          zbH(j,1:MAXEQNH)=zbH(j,1:MAXEQNH) + zdvalHdt(1:MAXEQNH)*dshapH_edge(j)*wa
!    
!         if needed, recompute stiffness matrix
          if (nord /= nord_old) then
!                  
!           2nd loop over 1D H1-bubbles
            do i=1,ndofH_edge
!
!             STIFFNESS MATRIX for projection (real-valued)
              aaH(i,j) = aaH(i,j) + dshapH_edge(i)*dshapH_edge(j)*wa
!              
            enddo
          endif
        enddo
      enddo
!
!     printing
      if (iprint.eq.1) then
        write(*,*) 'dhpedge: LOAD VECTOR AND STIFFNESS MATRIX (H1) = '
        do ii=1,ndofH_edge
          write(*,7036) zbH(ii,1:MAXEQNH)
        enddo
        do ii=1,ndofH_edge
          write(*,7005) aaH(ii,1:ndofH_edge)
        enddo
 7036   format(4(2e12.5,2x))
 7005   format(1x,10f8.3)
      endif
!
!     projection matrix leading dimension (maximum number of 1D bubbles)
      naH=MAXP-1
!    
!     if needed, compute factorization
      if (nord /= nord_old) then
!    
!       over-write aaH with its LU factorization
        call dgetrf(ndofH_edge,ndofH_edge,aaH,naH,ipivH,info)
!
!       check that factorization was successful
        if (info /= 0) then
          write(*,*)'dhpedge: H1 DGETRF RETURNED INFO = ',info
          call logic_error(FAILURE,__FILE__,__LINE__)
        endif
!    
!       update projection order
        nord_old=nord
!        
      endif
!    
!     solve linear system
      if (ndofH_edge > 0) then
!
!       copy load vector
        zuH(1:ndofH_edge,:) = zbH(1:ndofH_edge,:)
!    
#if C_MODE
!
!       apply pivots to load vector
        call zlaswp(MAXEQNH,zuH(1:ndofH_edge,:),naH,1,ndofH_edge,ipivH,1)
!
!       compute real part
        duH_real(1:ndofH_edge,:) = real( zuH(1:ndofH_edge,:))
!
!       compute imaginary part
        duH_imag(1:ndofH_edge,:) = aimag(zuH(1:ndofH_edge,:))
!
!       triangular solves for real part
        call dtrsm('L','L','N','U',ndofH_edge,MAXEQNH,1.d0,aaH,naH, duH_real,naH)
        call dtrsm('L','U','N','N',ndofH_edge,MAXEQNH,1.d0,aaH,naH, duH_real,naH)
!    
!       triangular solves for imaginary part
        call dtrsm('L','L','N','U',ndofH_edge,MAXEQNH,1.d0,aaH,naH, duH_imag,naH)
        call dtrsm('L','U','N','N',ndofH_edge,MAXEQNH,1.d0,aaH,naH, duH_imag,naH)
!         
!       combine real and imaginary parts by forcing type to DOUBLE precision complex 
        zuH(1:ndofH_edge,:) = dcmplx(duH_real(1:ndofH_edge,:), duH_imag(1:ndofH_edge,:))
!        
#else
!    
!       apply pivots to load vector
        call dlaswp(MAXEQNH,zuH,naH,1,ndofH_edge,ipivH,1)
!
!       triangular solves
        call dtrsm('L','L','N','U',ndofH_edge,MAXEQNH,1.d0,aaH,naH, zuH,naH)
        call dtrsm('L','U','N','N',ndofH_edge,MAXEQNH,1.d0,aaH,naH, zuH,naH)
!    
#endif
!    
      endif
!    
!     printing
      if (iprint.eq.1) then
        write(*,*) 'dhpedge: H1, k,zu(k) = '
        do k=1,ndofH_edge
          write(*,*) k,zuH(k,1:MAXEQNH)
        enddo
        call pause
      endif
!    
!     save dof's, skipping irrelevant entries
!
!     decoded node case, indicating supported variables
      call decod(Icase,2,NR_PHYSA, ncase)
!    
!     initialize global variable counter, and node local variable counter
      ivarH=0 ; nvarH=0
!    
!     loop through multiple copies of variables (RHS's)
      do j=1,NRCOMS
!    
!       loop through physical attributes
        do i=1,NR_PHYSA
!    
!         loop through components of physical attribute
          do k=1,NR_COMP(i)
!          
            select case(DTYPE(i))
!
!           H1 component
            case('contin')
!
!             update global counter
              ivarH = ivarH + 1
!
!             Dirichlet component
              if (ncase(i) == 1) then
!
!               update node local conter
                nvarH = nvarH + 1
!
!               store Dirichlet dof
                ZnodH(nvarH,1:ndofH_edge) = zuH(1:ndofH_edge,ivarH)
!                
              endif
            endselect
          enddo
        enddo
      enddo
!
!
endsubroutine dhpedgeH
