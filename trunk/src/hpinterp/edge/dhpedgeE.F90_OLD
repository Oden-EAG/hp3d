!> Purpose : update Hcurl edge dof for a Dirichlet edge
!!           performing L2 projection
!! @param[in]  Iflag        - a flag specifying which of the objects
!!                            5 pris, 6 hexa, 7 tetr, 8 pyra
!! @param[in]  No           - number of a specific object 
!! @param[in]  Etav         - reference coordinates of the element vertices
!! @param[in]  Type         - element (middle node) type
!! @param[in]  Icase        - the mid-edge node case
!! @param[in]  Nedge_orient - edge orientation (not needed really)
!! @param[in]  Nface_orient - face orientation (not needed really)
!! @param[in]  Norder       - element order
!! @param[in]  Iedg         - edge number 
!! 
!! @param[out] ZnodE        - H(curl) dof for the edge
!!
!> @date Jan 15
!------------------------------------------------------------------------------------
!
#include "implicit_none.h"
!
subroutine dhpedgeE(Mdle,Iflag,No,Etav,Type,Icase,Nedge_orient,Nface_orient,Norder,Iedg, ZnodE)
!
      use control
      use parameters
      use physics
      use element_data
!      
      implicit none
      integer,                                    intent(in)  :: Iflag,No,Mdle
      integer,                                    intent(in)  :: Icase,Iedg
      real*8,  dimension(3,8),                    intent(in)  :: Etav
      character(len=4),                           intent(in)  :: Type
      integer, dimension(12),                     intent(in)  :: Nedge_orient
      integer, dimension(6),                      intent(in)  :: Nface_orient
      integer, dimension(19),                     intent(in)  :: Norder
      VTYPE,   dimension(NRCOMS*NREQNE(Icase),*), intent(out) :: ZnodE
!
  integer, dimension(19)             :: norder_1
  real*8,  dimension(MAXbrickH)      ::  shapH
  real*8,  dimension(3,MAXbrickH)    :: dshapH
  !
  ! edge parameterization and shape function
  real*8,  dimension(3)              :: xi, eta, x, dxdt, dxidt
  real*8,  dimension(3,3)            :: dxdxi,dxdeta,detadxi
  real*8,  dimension(MAXP)           :: shapE_edge

  ! geometry for solelm
  real*8 :: xnod(3,MAXbrickH)
  
  VTYPE :: &
       zdofH_c(MAXEQNH,MAXbrickH),zdofE_c(MAXEQNE,MAXbrickE),&
       zdofV_c(MAXEQNV,MAXbrickV),zdofQ_c(MAXEQNQ,MAXbrickQ)

  VTYPE :: &
       ZsolH(MAXEQNH),ZgradH(MAXEQNH,3), &
       ZsolE(3,MAXEQNE),ZcurlE(3,MAXEQNE), &
       ZsolV(3,MAXEQNV),ZdivV(MAXEQNV), &
       ZsolQ(MAXEQNQ),zEt

  integer :: nrp, nflag
  real*8 :: dt

  !
  ! Dirichlet BC data at a point and its Piola transformations
  VTYPE :: &
       zvalH(MAXEQNH), zdvalH(MAXEQNH,3), &
       zvalE(3,MAXEQNE), zvalExi(3,MAXEQNE), zvalEt(MAXEQNE), &
       zdvalE(3,MAXEQNE,3), zdvalExi(3,MAXEQNE,3), &
       zvalV(3,MAXEQNV), zdvalV(3,MAXEQNV,3)

  integer, dimension(NR_PHYSA)       :: ncase

  ! linear systems for H1, Hcurl
  real*8,  dimension(MAXP, MAXP)     :: aaE
  integer, dimension(MAXP, 1)        :: ipivE

  ! load vector and solution
  VTYPE,   dimension(MAXP  ,MAXEQNE) :: zbE,zuE
  real*8,  dimension(MAXP  ,MAXEQNE) :: duE_real,duE_imag


  integer :: &
       i,j,k,l,ii,ivarE,nvarE,naE,iprint, info, &
       nint,ndofH_edge,ndofE_edge,ndofV_edge,ndofQ_edge, &
       nrdofH, nord, nord_old
  real*8,  dimension(MAXP+1)         :: xi_list, wa_list 
  real*8                             :: t, wa

  ! to reuse precalculated one
  save nord_old, aaE, ipivE
  data nord_old /0/
!  
!----------------------------------------------------------------------
!
!     printing flag
      iprint=0
!    
!     edge order of approximation
      nord = Norder(Iedg)
!
!     if needed, clear (real-valued) projection matrix
      if (nord /= nord_old) then 
        aaE=0.d0
      endif
!      
!     initialize (possibly complex-valued) load vector
      zbE=ZERO
!
!     number of edge dof's
      call ndof_nod('medg',nord, ndofH_edge,ndofE_edge,ndofV_edge,ndofQ_edge)
!
!     check number of edge H(curl) dof's
      if (ndofE_edge == 0) then
        write(*,*) 'dhpedge: # of dof is zero, Type, Norder = ', Type, Norder
        call logic_error(ERR_INVALID_VALUE,__FILE__,__LINE__)
      endif
!
!     initiate element order to 1st order
      call initiate_order(Type, norder_1)
!
!     1D integration rule
      INTEGRATION=1   ! overintegrate
      call set_1Dint(nord, nint, xi_list, wa_list)
      INTEGRATION=0   ! reset
!    
!     loop over integration points
      do l=1,nint
!
!       Gauss point and weight
        t  = xi_list(l)
        wa = wa_list(l)
!    
!       determine edge parameterization for line integral
        call edge_param(Type,Iedg,t, xi,dxidt)
!
!       printing
        if (iprint.eq.1) then
          write(*,8000) l,t
8000      format('dphmedge: l,t      = ',i3,e12.5)
          write(*,8001) xi(1:3),dxidt(1:3)
8001      format('dhpmedge: xi,dxidt = ',3f8.3,2x,3f8.3)
        endif
!
!       element vertex shape functions
        call shape3H(Type,xi,norder_1,Nedge_orient,Nface_orient, nrdofH,shapH,dshapH)
!     
!       MASTER --> REFERENCE : Eta = Eta(Xi)
        eta(1:3)=0.d0 ; detadxi(1:3,1:3)=0.d0 
        do k=1,nrdofH
          eta(1:3) = eta(1:3) + Etav(1:3,k)*shapH(k)
          do i=1,3
            detadxi(1:3,i) = detadxi(1:3,i) + Etav(1:3,k)*dshapH(i,k)
          enddo
        enddo
!
!       REFERENCE --> PHYSICAL : X = X(Eta)
        select case(Iflag)
        case(5) ; call prism(No,eta, x,dxdeta)
        case(6) ; call  hexa(No,eta, x,dxdeta)
        case(7) ; call tetra(No,eta, x,dxdeta)
        case(8) ; call pyram(No,eta, x,dxdeta)
        case default
          write(*,*) 'dhpedge: Type, Iflag = ', Type, Iflag
          call logic_error(ERR_INVALID_VALUE,__FILE__,__LINE__)
        endselect
!
!       evaluate geometry map derivative dX/dXi
        dxdxi(1:3,1:3) = 0.d0
        do i=1,3
          do j=1,3
            dxdxi(1:3,i) = dxdxi(1:3,i) + dxdeta(1:3,j)*detadxi(j,i)
          enddo
        enddo
!
!       evaluate the Dirichlet data (this is an application-specific routine)
        call dirichlet(Mdle,x,Icase, zvalH,zdvalH,zvalE,zdvalE,zvalV,zdvalV)
!        
!       printing
        if (iprint.ne.0) then
          write(*,7032) l,zvalE(1:3,1)
7032      format('dhpedge: l,zvalE = ',i3,3(2e12.5,2x))
        endif
!
!       pull back E to master coordinates
        zvalExi(1:3,1:MAXEQNE)=ZERO
        do i=1,3
          do j=1,3
            zvalExi(i,1:MAXEQNE) = zvalExi(i,1:MAXEQNE) + zvalE(j,1:MAXEQNE)*dxdxi(j,i)
          enddo
        enddo
!
!       printing
        if (iprint.ne.0) then
          write(*,7034) l,zvalExi
7034      format('dhpedge: l,zvalExi = ',i3,9(2e12.5))
        endif
!
!       evalute tangential component
        zvalEt(1:MAXEQNE)=ZERO
        do i=1,3
          zvalEt(1:MAXEQNE) = zvalEt(1:MAXEQNE) + zvalExi(i,1:MAXEQNE)*dxidt(i)
        enddo
!
!       printing
        if (iprint.ne.0) then
          write(*,7035) l,zvalEt(1)
7035      format('dhpedge: l,zvalEt = ',i3,2e12.5)
        endif
!
!       1D H(curl)-bubbles
        call shapEbe(t,nord,Nedge_orient(Iedg), ndofE_edge,shapE_edge)
!        
!       1st loop over 1D H(curl)-bubbles
        do j=1,ndofE_Edge
!
!         LOAD VECTOR for projection (possibly complex-valued)
          zbE(j,1:MAXEQNE) = zbE(j,1:MAXEQNE) + zvalEt(1:MAXEQNE)*shapE_edge(j)*wa
!   
!         if needed, recompute stiffness matrix
          if (nord /= nord_old) then
!
!           2D loop over 1D H(curl)-bubbles
            do i=1,ndofE_Edge
              aaE(i,j) = aaE(i,j) + shapE_edge(i)*shapE_edge(j)*wa
            enddo
          endif
        enddo
      enddo
!
!     projection matrix leading dimension (maximum number of 1D bubbles)
      naE=MAXP
!
!     if needed, compute factorization
      if (nord.ne.nord_old) then
!    
!       over-write aaE with its LU factorization
        call dgetrf(ndofE_edge,ndofE_edge,aaE,naE,ipivE,info)
!
!       check that factorization was successful
        if (info.ne.0) then
          write(*,*)'dhpedge: H(curl) DGETRF RETURNED INFO = ',info
          call logic_error(FAILURE,__FILE__,__LINE__)
        endif
!
!       update projection order
        nord_old=nord
!        
      endif
!
!     solve linear system
      if (ndofE_edge > 0) then
!
!       copy load vector
        zuE(1:ndofE_edge,:) = zbE(1:ndofE_edge,:)
!    
#if C_MODE
!
!       apply pivots to load vector
        call zlaswp(MAXEQNE,zuE(1:ndofE_edge,:),naE,1,ndofE_edge,ipivE,1)
!    
!       compute real part
        duE_real(1:ndofE_edge,:) = real( zuE(1:ndofE_edge,:))
!
!       compute imaginary part
        duE_imag(1:ndofE_edge,:) = aimag(zuE(1:ndofE_edge,:))
!
!       triagular solve for real part
        call dtrsm('L','L','N','U',ndofE_edge,MAXEQNE,1.d0,aaE,naE, duE_real,naE)
        call dtrsm('L','U','N','N',ndofE_edge,MAXEQNE,1.d0,aaE,naE, duE_real,naE)
!    
!       triagular solve for imaginary part
        call dtrsm('L','L','N','U',ndofE_edge,MAXEQNE,1.d0,aaE,naE, duE_imag,naE)
        call dtrsm('L','U','N','N',ndofE_edge,MAXEQNE,1.d0,aaE,naE, duE_imag,naE)
!    
!       combine real and imaginary parts by forcing type to DOUBLE precision complex 
        zuE(1:ndofE_edge,:) = dcmplx(duE_real(1:ndofE_edge,:), duE_imag(1:ndofE_edge,:))
!        
#else
!
!       apply pivots to load vector
        call dlaswp(MAXEQNE,zuE(1:ndofE_edge,:),naE,1,ndofE_edge,ipivE,1)
!
!       triangular solves
        call dtrsm('L','L','N','U',ndofE_edge,MAXEQNE,1.d0,aaE,naE, zuE,naE)
        call dtrsm('L','U','N','N',ndofE_edge,MAXEQNE,1.d0,aaE,naE, zuE,naE)
!        
#endif
!
      endif
!    
!     printing
      if (iprint.eq.1) then
        write(*,*) 'dhpedge: Hcurl, k,zu(k) = '
        do k=1,ndofE_edge
          write(*,*) k,zuE(k,1:MAXEQNE)
        enddo
        call pause
      endif
!
!     save the dof, skipping irrelevant entries
!
!     decoded node case, indicating supported variables
      call decod(Icase,2,NR_PHYSA, ncase)
!    
!     initialize global variable counter, and node local variable counter
      ivarE=0; nvarE=0
!    
!     loop through multiple copies of variables (RHS's)
      do j=1,NRCOMS
!    
!       loop through physical attributes
        do i=1,NR_PHYSA
!    
!         loop through components of physical attribute
          do k=1,NR_COMP(i)
!          
            select case(DTYPE(i))
!
!           H(curl) component
            case('tangen')
!
!             update global counter
              ivarE = ivarE + 1
!
!             Dirichlet component
              if (ncase(i) == 1) then
!
!               update node local counter
                nvarE = nvarE + 1
                ZnodE(nvarE,1:ndofE_edge) = zuE(1:ndofE_edge,ivarE)
!                
              endif
            endselect
          enddo
        enddo
      enddo
!
!
  !!! be careful when you activate this flag, 
  !!! set iprint_parameter = mdle from update_Ddof
!!  iprint = iprint_parameter
  iprint = 0

  if (iprint.ne.0) then
    nrp=10; dt=1.d0/nrp
    call nodcor(Mdle, xnod) 
    call solelm(Mdle, zdofH_c,zdofE_c,zdofV_c,zdofQ_c)

    write(*,*) 'zuE ',zuE(1:ndofE_edge,1) 
    write(*,*) 'zdE ',zdofE_c( (Iedg-1)*ndofE_edge+1:(Iedg)*ndofE_edge,1 )

    ! loop through points along the edge
    Nflag = 1
    do i=0,nrp
      t = i*dt
      call edge_param(Type,Iedg,t, xi,dxidt)
      call shapEbe(t,nord,Nedge_orient(Iedg), &
                   ndofE_edge,shapE_edge)
      zEt = ZERO
      do j=1,ndofE_edge
        write(*,6048) j,zuE(j,1),shapE_edge(j)
6048    format('dhpedge: j,zuE(j,1),shapE_edge(j) = ',i2,2e12.5,2x,e12.5)
        zEt = zEt + zuE(j,1)*shapE_edge(j)
      enddo

      call soleval(Mdle,xi, &
            Nedge_orient,Nface_orient,Norder,&
            xnod,zdofH_c,zdofE_c,zdofV_c,zdofQ_c,nflag, &
            x,dxdxi,&
            ZsolH,ZgradH,ZsolE,ZcurlE,ZsolV,ZdivV,ZsolQ)

      dxdt(1:3) = dxdxi(1:3,1)*dxidt(1) + dxdxi(1:3,2)*dxidt(2) &
                + dxdxi(1:3,3)*dxidt(3) 

      call dirichlet( &
           Mdle,x,Icase, &
           zvalH,zdvalH, &
           zvalE,zdvalE, &
           zvalV,zdvalV)

      write(*,9002) iprint,Nedge_orient(Iedg),Iedg, i,t,xi(1:3),x(1:3)
9002  format( &
           'Mdle,ort,iedg = ',3i5,' i = ',i2, &
           ' t = ',f8.3,' xi = ',3f8.3,' x = ',3f8.3)
      write(*,9001) &
           zvalE(1,1)*dxdt(1)+zvalE(2,1)*dxdt(2)+zvalE(3,1)*dxdt(3),&
           zsolE(1,1)*dxdt(1)+zsolE(2,1)*dxdt(2)+zsolE(3,1)*dxdt(3),&
           zEt, &
           zvalE(1,1)*dxdt(1)+zvalE(2,1)*dxdt(2)+zvalE(3,1)*dxdt(3) - zEt
9001  format( &
           ' zvalE = ',(2e12.5,2x),&
           ' zsolE = ',(2e12.5,2x),&
           ' zEt   = ',(2e12.5,2x),&
           ' diff  = ',(2e12.5,2x))

    enddo
    call pause
  endif
!
!
endsubroutine dhpedgeE

