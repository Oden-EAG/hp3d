!
!> Purpose : determine H1 face dof interpolating H1 Dirichlet data using 
!            PB interpolation
!!           
!! @param[in]  Iflag        - a flag specifying which of the objects the face is on
!!                            5 pris, 6 hexa, 7 tetr, 8 pyra
!! @param[in]  No           - number of a specific object 
!! @param[in]  Etav         - reference coordinates of the element vertices
!! @param[in]  Type         - element (middle node) type
!! @param[in]  Icase        - the face node case
!! @param[in]  Nedge_orient - edge orientation (not needed really)
!! @param[in]  Nface_orient - face orientation (not needed really)
!! @param[in]  Norder       - element order
!! @param[in]  Iface        - face number 
!! @param[in]  ZdofH        - H1 dof for the element (vertex and edge values)
!! 
!! @param[out] ZnodH        - H1 dof for the edge
#include "implicit_none.h"
  subroutine dhpfaceH(Mdle,Iflag,No,Etav, Type,Icase, &
                      Nedge_orient,Nface_orient,Norder,Iface, &
                      ZdofH,ZnodH)
  use control
  use parameters
  use physics
  use element_data
  implicit none
  !
  ! ** Arguments
  !-----------------------------------------------------------------------
  integer,                                    intent(in)  :: Iflag,No,Mdle
  integer,                                    intent(in)  :: Icase,Iface
  real*8,  dimension(3,8),                    intent(in)  :: Etav
  character(len=4),                           intent(in)  :: Type
  integer, dimension(12),                     intent(in)  :: Nedge_orient
  integer, dimension(6),                      intent(in)  :: Nface_orient
  integer, dimension(19),                     intent(in)  :: Norder
  !
  VTYPE,   dimension(MAXEQNH,MAXbrickH),      intent(in)  :: ZdofH
  VTYPE,   dimension(NRCOMS*NREQNH(Icase),*), intent(out) :: ZnodH
  !
  ! ** Locals
  !-----------------------------------------------------------------------
  ! for vertices and edges
  integer, dimension(5)                 :: norder_face
  integer, dimension(19)                :: norder_1
  real*8,  dimension(MAXbrickH)         ::  shapH
  real*8,  dimension(3,MAXbrickH)       :: dshapH
  !
  ! ** parameterization
  real*8, dimension(3)                  :: xi, eta, x
  real*8, dimension(3,2)                :: dxdt, dxidt
  real*8, dimension(3,3)                :: dxdxi,dxdeta,detadxi
  real*8, dimension(  MAXmdlqH)         ::  shapH_face
  real*8, dimension(2,MAXmdlqH)         :: dshapH_face
  !
  ! Dirichlet BC data at a point
  VTYPE :: &
       zvalH(MAXEQNH), &
       zdvalH(MAXEQNH,3), zdvalHdxi(MAXEQNH,3),zdvalHdt(MAXEQNH,2), &
       zvalE(3,MAXEQNE), zvalExi(3,MAXEQNE), zvalEt(2,MAXEQNE), &
       zdvalE(3,MAXEQNE,3), zdvalExi(3,MAXEQNE,3), &
       zcvalE(3,MAXEQNE), zcvalExi(3,MAXEQNE), zcvalEt(MAXEQNE), &
       zvalV(3,MAXEQNV), zdvalV(3,MAXEQNV,3)
  !
  integer, dimension(NR_PHYSA)          :: ncase
  !
  ! linear systems
  real*8,  dimension(MAXMdlqH,MAXMdlqH) :: aaH
  integer, dimension(MAXMdlqH)          :: ipivH
  !
  ! load vector and solution
  VTYPE,   dimension(MAXMdlqH,MAXEQNH)  :: zbH,zuH
  real*8,  dimension(MAXMdlqH,MAXEQNH)  :: duH_real,duH_imag
  !
  ! quadrature
  real*8,  dimension(2, MAXquadH)       :: xi_list
  real*8,  dimension(   MAXquadH)       :: wa_list 
  real*8,  dimension(2)                 :: t
  real*8                                :: wa
  !
  integer :: &
       i,j,k,l,ii,ivar,ivarH,nvarH,naH,iprint, info, &
       nint,ndofH_face,ndofE_face,ndofV_face,ndofQ_Face, &
       nrdofH, nord, nord_old, norient_old
  !
  ! to reuse precalculated stiffness matrix
  logical :: recompute
  save nord_old, norient_old, aaH, ipivH
  data nord_old /0/
  data norient_old /-1/
  !
  !-----------------------------------------------------------------------
  iprint = 0
  ! 
  ! decide whether we can reuse the previous stiffness matrix
  nord = Norder(nedge(Type) + Iface)
  if ((nord.eq.nord_old).and.(Nface_orient(Iface).eq.norient_old)) then
    recompute = .FALSE.
  else
    recompute = .TRUE.
  endif
  if (recompute) then
     aaH = 0.d0
  endif
  zbH = ZERO
  !
  call ndof_nod(face_type(Type,Iface),nord, &
       ndofH_face,ndofE_face,ndofV_face,ndofQ_face)
  ! if # of dof is zero, return, nothing to determine
  if (ndofH_face.eq.0) then
     return
  endif
  !
  ! grep face order to find out quadrature information 
  INTEGRATION=1
  call face_order(Type,Iface,Norder, norder_face)
  call set_2Dint(face_type(Type,Iface),norder_face, &
       nint,xi_list,wa_list)
  INTEGRATION=0
  !
  ! set order edge only, exclude face dofs by setting the order to one
  call initiate_order(Type, norder_1)
  norder_1(1:nedge(Type)) = Norder(1:nedge(Type))
  !
  ! loop through integration points
  do l=1,nint
     t(1:2) = xi_list(1:2,l)
     wa     = wa_list(l)
     !
     ! face parametrization
     call face_param(Type,Iface,t, xi,dxidt)
     !
     ! compute element H1 shape functions
     call shape3H( &
          Type,xi, &
          norder_1,Nedge_orient,Nface_orient, &
          nrdofH,shapH,dshapH)
     !
     !------------------------------------------------------
     ! ** parameterization
     !
     ! evaluate reference coordinates of the point
     eta(1:3)         = 0.d0
     detadxi(1:3,1:3) = 0.d0
     do k=1,nvert(Type)
        eta(1:3) = eta(1:3) + etav(1:3,k)*shapH(k)
        do i=1,3
           detadxi(1:3,i) = detadxi(1:3,i) + etav(1:3,k)*dshapH(i,k)
        enddo
     enddo
     !
     ! evaluate derivatives of the physical coordinates wrt
     ! the reference coordinate
     select case(Iflag)
     case(5);        call prism(No,eta, x,dxdeta)
     case(6);        call  hexa(No,eta, x,dxdeta)
     case(7);        call tetra(No,eta, x,dxdeta)
     case(8);        call pyram(No,eta, x,dxdeta)
     case default
        write(*,*) 'dhpface: Type = ', Type
        call logic_error(ERR_INVALID_VALUE,__FILE__,__LINE__)
     end select
     !
     ! get Dirichlet data at the point
     call dirichlet( & 
          Mdle,x,Icase, &
          zvalH,zdvalH, &
          zvalE,zdvalE, &
          zvalV,zdvalV)
     !
     ! evaluate derivatives wrt master coordinates
     dxdxi(1:3,1:3) = 0.d0
     do i=1,3
        do j=1,3
           dxdxi(1:3,i) = dxdxi(1:3,i) + dxdeta(1:3,j)*detadxi(j,i)
        enddo
     enddo
     !
     ! remove the contribution from vertices and edges
     zdvalHdxi(1:MAXEQNH,1:3) = ZERO
     do k=1,nrdofH
        do i=1,3
           zdvalHdxi(1:MAXEQNH,i) &
                = zdvalHdxi(1:MAXEQNH,i) - ZdofH(1:MAXEQNH,k)*dshapH(i,k)
        enddo
     enddo
     !
     ! add derivatives of Dirichlet data wrt master coordinates
     do i=1,3
        do j=1,3
           zdvalHdxi(1:MAXEQNH,i) &
                = zdvalHdxi(1:MAXEQNH,i) + zdvalH(1:MAXEQNH,j)*dxdxi(j,i)
        enddo
     enddo
     !
     ! evaluate derivative wrt face coordinate
     zdvalHdt(1:MAXEQNH,1:2) = ZERO
     do i=1,2
        do j=1,3
           zdvalHdt(1:MAXEQNH,i) &
                = zdvalHdt(1:MAXEQNH,i) + zdvalHdxi(1:MAXEQNH,j)*dxidt(j,i)
        enddo
     enddo
     !
     !------------------------------------------------------
     ! ** 2D face H1 shape functions
     call shapHb2(face_type(Type,Iface), t, nord, &
          Nface_orient(Iface), ndofH_face,shapH_face,dshapH_face)
     !------------------------------------------------------
     ! ** construct matrix for projection
     do j=1,ndofH_face
        do k=1,2
           zbH(j,1:MAXEQNH) &
                = zbH(j,1:MAXEQNH) &
                + zdvalHdt(1:MAXEQNH,k)*dshapH_face(k,j)*wa
        enddo
        !
        ! accumulate for the stiffness matrix
        if (recompute) then
           do i=1,ndofH_face
              do k=1,2
                 aaH(i,j) &
                      = aaH(i,j) &
                      + dshapH_face(k,i)*dshapH_face(k,j)*wa
              enddo
           enddo
        endif
     enddo
     !------------------------------------------------------
  enddo
  !
  if (iprint.eq.1) then
     write(*,*) 'dhpface: LOAD VECTOR AND STIFFNESS MATRIX(H1) = ', &
                 ndofH_face
     do ii=1,ndofH_face
        write(*,7015) 'zbH=',zbH(ii,1:MAXEQNH)
        write(*,7016) 'aaH=',aaH(ii,1:ndofH_face)
     enddo
  !
7015    format(a4,10(2e12.5,2x))
7016    format(a4,1x,10(e12.5,2x))
  !
  endif
  !------------------------------------------------------
  ! solve the linear system
  naH = MAXmdlqH
  !
  ! if it is not same order, factorize it
  if (recompute) then
     call dgetrf(ndofH_face,ndofH_face,aaH,naH,ipivH,info)
     if (info.ne.0) then
        write(*,*)'dhpface: H1 DGETRF RETURNED INFO = ',info
        call logic_error(FAILURE,__FILE__,__LINE__)
     endif
     nord_old = nord
     norient_old = Nface_orient(Iface)
  endif
  !
  ! solve the matrix
  if (ndofH_face.gt.0) then
     zuH(1:ndofH_face,:) = zbH(1:ndofH_face,:)

#if C_MODE
     call zlaswp(MAXEQNH,zuH(1:ndofH_face,:),naH,1,ndofH_face,ipivH,1)
     duH_real(1:ndofH_face,:) = real(zuH(1:ndofH_face,:))
     duH_imag(1:ndofH_face,:) = aimag(zuH(1:ndofH_face,:))

     call dtrsm('L','L','N','U',ndofH_face,MAXEQNH,1.d0,aaH,naH, &
          duH_real,naH)
     call dtrsm('L','U','N','N',ndofH_face,MAXEQNH,1.d0,aaH,naH, &
          duH_real,naH)

     call dtrsm('L','L','N','U',ndofH_face,MAXEQNH,1.d0,aaH,naH, &
          duH_imag,naH)
     call dtrsm('L','U','N','N',ndofH_face,MAXEQNH,1.d0,aaH,naH, &
          duH_imag,naH)

     zuH(1:ndofH_face,:) &
          = cmplx(duH_real(1:ndofH_face,:), duH_imag(1:ndofH_face,:))
#else
     call dlaswp(MAXEQNH,zuH(1:ndofH_face,:),naH,1,ndofH_face,ipivH,1)
     call dtrsm('L','L','N','U',ndofH_face,MAXEQNH,1.d0,aaH,naH, &
          zuH,naH)
     call dtrsm('L','U','N','N',ndofH_face,MAXEQNH,1.d0,aaH,naH, &
          zuH,naH)
#endif

  endif

  !------------------------------------------------------
  if (iprint.eq.1) then
     write(*,*) 'dhpface: H1, k,zu(k) = '
     do k=1,ndofH_face
        write(*,*) k,zuH(k,1:MAXEQNH)
     enddo
     call pause
  endif
  !------------------------------------------------------
  ! save the dof, skipping irrelevant entries
  call decod(Icase,2,NR_PHYSA, ncase)
  if (iprint.eq.1) then
     write(*,*) 'dhpface: ncase = ', ncase
  endif

  !------------------------------------------------------
  ivarH=0; nvarH=0

  ! loop through multiple copies of variables
  do j=1,NRCOMS

     ! loop through physical attributes
     do i=1,NR_PHYSA
        
        ! loop through components
        do k=1,NR_COMP(i)
           select case(DTYPE(i))
           case('contin')
              ivarH = ivarH + 1
              if (ncase(i).eq.1) then
                 nvarH = nvarH + 1
                 ZnodH(nvarH,1:ndofH_face) = zuH(1:ndofH_face,ivarH)
              endif
           end select
        enddo
     enddo
  enddo

end subroutine dhpfaceH
