!---------------------------------------------------------------------------------------
subroutine split_surface(Nsplit,Nr_bound,Ns_bound,Nr_confm,Ns_confm,Dh1,Dh2)
!---------------------------------------------------------------------------------------
! LATEST REVISION      - Jul 09
!
! PURPOSE              - Routine enables generation of a "membrane"
!                        by splitting points lying on a predefined
!                        surface. Triangles lying on the surface are
!                        duplicated and thin prisms, tetrahedra
!                        and pyramids are generated.
!
! ARGUMENTS
!     in:
!            Nsplit    - plane to be split and the twin plane resulting
!                        from splitting
!            Nr_bound  - number of surfaces bounding the area to be split
!            Ns_bound  - list of bounding surfaces
!            Nr_confm  - number of surfaces to conform to
!            Ns_confm  - list of surfaces to conform to
!            Dh1       - shift on NEG side of split surface
!            Dh2       - shift on POS side of split surface
!     out:
!                        changes recorded in GMP data structure
!
! REMARKS:
!   1. plane needs to be given in 'VecPt' form
!   2. for newly created POINTS, CURVES, TRIANGLES, RECTANGLES, TETRRAS,  PRISMS, and
!      PYRAMIDS routine generates following GMP info:
!
!        POINTS%Type            = 'Regular'
!              %Rdata(1:3)      = coordinates
!
!        CURVES%Type            = 'Seglin'
!              %EndPoNo(1:2)    = endpoints numbers
!
!        TRIANGLES%Type         = 'PlaneTri','PTITri'
!                 %VertNo       = vertex numbers
!                 %Idata(1)     = surface number, if 'PTITri'
!
!        RECTANGLES%Type        = 'BilQua','PTIRec'
!                  %VertNo(1:3) = vertex numbers
!                  %Idata(1)    = surface number, if 'PTIRec'
!
!        TETRAS%Type            = 'Linear'
!              %VertNo(1:4)     = vertex numbers
!              %Domain          = domain number
!
!        PRISMS%Type            = 'TIprism'
!              %VertNo(1:6)     = vertex numbers
!              %Domain          = domain number
!
!        PYRAMIDS%Type          = 'Linear'
!              %VertNo(1:5)     = vertex numbers
!              %Domain          = domain number
!
!   3. full geometry connectivities are generated by routine connect and input_NETGEN
!---------------------------------------------------------------------------------------
! MODULES
  use kinds
  use SPLIT_SURF
!---------------------------------------------------------------------------------------
! DUMMY ARGUMENTS
  integer, dimension(Nr_bound), intent(in) :: Ns_bound
  integer, dimension(Nr_confm), intent(in) :: Ns_confm
  integer,                      intent(in) :: Nsplit,Nr_bound,Nr_confm
  real(8),                      intent(in) :: Dh1,Dh2
!---------------------------------------------------------------------------------------
! printing flag (0,1,2)
#define I_PRINT 0
!
#if I_PRINT >= 1
    write(*,*)'split_surface: splitting surface ',Nsplit
#endif
! ..intialize shared variables
    Nr_bound_MOD = Nr_bound
    Nr_confm_MOD = Nr_confm
    call allocate_Ns_bound_MOD
    call allocate_Ns_confm_MOD
    Ns_bound_MOD = Ns_bound
    Ns_confm_MOD = Ns_confm
    Nsplit_MOD   = Nsplit
    Dh1_MOD      = Dh1
    Dh2_MOD      = Dh2
    nrcurve_orig = NRCURVE
    nrtrian_orig = NRTRIAN
    nrrecta_orig = NRRECTA
    nrprism_orig = NRPRISM
    nrtetra_orig = NRTETRA
    nrpyram_orig = NRPYRAM
#if I_PRINT >= 2
! ..printing statements
    write(*,*)'split_surface: shared variables initialized.'
    write(*,*)' Nr_bound     = ',Nr_bound
    write(*,*)' Nr_bound_MOD = ',Nr_bound_MOD
    write(*,*)' Ns_bound     = ',Ns_bound(1:Nr_bound)
    write(*,*)' Ns_bound_MOD = ',Ns_bound_MOD(1:Nr_bound_MOD)
    write(*,*)' Nr_confm     = ',Nr_confm
    write(*,*)' Nr_confm_MOD = ',Nr_confm_MOD
    write(*,*)' Ns_confm     = ',Ns_confm(1:Nr_confm)
    write(*,*)' Ns_confm_MOD = ',Ns_confm_MOD(1:Nr_confm_MOD)
    write(*,*)' Nsplit       = ',Nsplit
    write(*,*)' Nsplit_MOD   = ',Nsplit_MOD
    write(*,*)' Dh1          = ',Dh1
    write(*,*)' Dh1_MOD      = ',Dh1_MOD
    write(*,*)' Dh2          = ',Dh2
    write(*,*)' Dh2_MOD      = ',Dh2_MOD
#endif
! ..specific splitting ruotines
    call allocate_NEW_POINT
    call allocate_FIGS_SPLIT
    call split_interface                        ! <-- TWIN PLANES
    call duplicate_POINTS_AND_CURVES            ! <-- TWIN POINTS, CONN CURVES
    call generate_remaining_CUR_TRI_REC         ! <-- TWIN CURVES, TWIN FIGURES, CONN FIGURES
    call update_connectivities_ORIG_ENTITIES
    call generate_PRI_TET_PYR                   ! <-- PRISMS, TETRAS, PYRAMIDS
! ..deallocate
    call deallocate_FIGS_SPLIT
    call deallocate_NEW_POINT
    call deallocate_NEW_CURVES
    call deallocate_Ns_bound_MOD
    call deallocate_Ns_confm_MOD
#if I_PRINT >= 1
    write(*,*)'split_surface: done!'
#endif
!
end subroutine split_surface
!---------------------------------------------------------------------------------------
!
!
!--------------------------------------------------------------------------------------
subroutine allocate_NEW_POINT
!--------------------------------------------------------------------------------------
! LATEST REVISION: Jul 09                                                             |
!                                                                                     |
! PURPOSE: routine classifies points into the following groups:                       |
!                                                                                     |
!    -3 = INT       points in the interior of the split surface                       |
!    -2 = POS_SIDE  points on the positive side of the split surface                  |
!    -1 = NEG_SIDE  points on the negative side of the split surface                  |
!     0 = INT^c     points not in the interior of split surface, i.e. complement      |
!                   of INT                                                            |
!--------------------------------------------------------------------------------------
  use SPLIT_SURF
  use GMP
  use control
!--------------------------------------------------------------------------------------
  IMPLICIT NONE
!--------------------------------------------------------------------------------------
! LOCAL VARIABLES
  real(8)               :: fval
  real(8), dimension(3) :: xp,dfdx
  real(8)               :: pos_shift, neg_shift
  integer               :: np,np_pos,np_neg
  integer               :: status
!--------------------------------------------------------------------------------------
! FUNCTIONS
  integer                :: if_bound
!--------------------------------------------------------------------------------------
! printing flag (0,1,2)
#define I_PRINT 0
!
#if I_PRINT >= 1
    write(*,*)'allocate_NEW_POINT: allocating NEW_POINT.'
#endif
! ..allocate new_point and initialize it to 0
    allocate(new_point(MAXNP), STAT = status)
    if (status .ne. 0) then
      write(*,*)'allocate_NEW_POINT: new_point not allocated.'
      stop
    endif
    new_point(1:MAXNP) = 0
! ..set maximum allowed positive and negative shifts to big values
    pos_shift = 1.d8;  neg_shift = 1.d8
    np_pos = 0;  np_neg = 0
! ..loop through points
    do np = 1, NRPOINT
      xp(1:3) = POINTS(np)%Rdata(1:3)
      call surf(Nsplit_MOD,xp, fval,dfdx)
!
! ******************************  CLASSIFY POINT  *********************************** |
! ....point is on the split surface
      if (abs(fval) .le. GEOM_TOL) then
        new_point(np) = -3
! ......point is on the split surface, but not inside INT, i.e. OUTSIDE or BOUDARY
        if (if_bound(xp,Nr_bound_MOD,Ns_bound_MOD) .le. 0)  new_point(np) = 0
! ....point is on NEG_SIDE
      elseif (fval .lt. -GEOM_TOL) then
! ......point is inside the bounding surfaces
        if (if_bound(xp,Nr_bound_MOD,Ns_bound_MOD) .eq. 1) then
          if (abs(fval) .lt. neg_shift) then
            np_neg = np
            neg_shift = abs(fval)
#if I_PRINT >= 2
            write(*,*)'allocate_NEW_POINT: neg_shift = ',neg_shift
#endif
          endif
        endif
        new_point(np) = -1
! ....point is on POS_SIDE
      elseif (fval .gt. GEOM_TOL) then
! ......point is inside the bounding surfaces
        if (if_bound(xp,Nr_bound_MOD,Ns_bound_MOD) .eq. 1) then
          if (abs(fval) .lt. pos_shift) then
            np_pos = np
            pos_shift = abs(fval)
#if I_PRINT >= 2
            write(*,*)'allocate_NEW_POINT: pos_shift = ',pos_shift
#endif
          endif
        endif
        new_point(np) = -2
      endif
! ..end of loop through points
    enddo
! ..check positive and negative shifts
    status = 0
    if (pos_shift .lt. Dh2_MOD) then
      status = 1
      write(*,*)'allocate_NEW_POINT: max allowed value Dh2 = ',pos_shift
      write(*,*)'                                      np  = ',np_pos
      call print_GMP
    endif
    if (neg_shift .lt. Dh1_MOD) then
      status = 1
      write(*,*)'allocate_NEW_POINT: max allowed value Dh1 = ',neg_shift
      write(*,*)'                                      np  = ',np_neg
      call print_GMP
    endif
    if (status .eq. 1)  stop
!
#if I_PRINT >= 2
    write(*,*)'allocate_NEW_POINT: max allowed value Dh1 = ',neg_shift
    write(*,*)'                                      np  = ',np_neg
    call print_GMP
    write(*,*)'allocate_NEW_POINT: max allowed value Dh2 = ',pos_shift
    write(*,*)'                                      np  = ',np_pos
    call print_GMP
#endif
!
#if I_PRINT >= 1
    write(*,*)'allocate_NEW_POINT: done!'
#endif
!
end subroutine allocate_NEW_POINT
!--------------------------------------------------------------------------------------
!
!
!
!----------------------------------------------------------------------------------
subroutine allocate_FIGS_SPLIT
!----------------------------------------------------------------------------------
! LATEST REVISION: Jul 09
!
! PURPOSE: routine identifies triangles and rectangles to be split.
!
! REMARKS: first iteration is needed to determine number of figures to split,
!          second interation fills up figs_split
!----------------------------------------------------------------------------------
  use GMP
  use SPLIT_SURF
  use control
!----------------------------------------------------------------------------------
  implicit none
!----------------------------------------------------------------------------------
! VARIABLES
  integer :: iter,ifig,nt,ion,iout,iv,np,nr
  integer :: status
!----------------------------------------------------------------------------------
! ..printing flag (0,1,2)
#define I_PRINT 0
!
#if I_PRINT >= 1
    write(*,*)'allocate_FIGS_SPLIT: allocating figures to be splitted...'
#endif
!
! ..loop through iterations
    do iter = 1, 2
! ....set figure counter to 0
      ifig = 0
!
! **************************  T R I A N G L E S  ******************************** |
! ....loop through triangles
      do nt = 1, NRTRIAN
!==================================================================================
!  ion:  number of vertices on INT                                                |
!  iout: number of vertices on POS/NEG_SIDE                                       |
!==================================================================================
        ion = 0;  iout = 0
! ......loop through vertices
        do iv = 1, 3
          np = TRIANGLES(nt)%VertNo(iv)
! ........vertex on INT
          if (new_point(np) .eq. -3) then
          ion = ion + 1
! ........vertex on POS/NEG_SIDE
          elseif (new_point(np) .lt. 0) then
            iout = iout + 1
          endif
        enddo
!=================================================================================
!  IF (at least one vertex is in INT) .AND. (no vertex is on POS/NEG_SIDE) THEN  |
!    figure needs to be split                                                    |
!=================================================================================
        if ((ion .ge. 1) .and. (iout .eq. 0)) then
! ........increment figure counter
          ifig = ifig + 1
! ........if 2nd iteration
          if (iter .eq. 2) then
! ..........store figure type (1 = trian,  2 = recta)
            figs_split(1,ifig) = 1
! ..........store triangle number
            figs_split(2,ifig) = nt
! ..........check if triangle is on the split surface
            if (.not. associated(TRIANGLES(nt)%Idata)) then
              write(*,3) nt
              stop
            elseif (TRIANGLES(nt)%Idata(1) .ne. Nsplit_MOD) then
              write(*,3) nt
3             format(' allocate_FIGS_SPLIT: nt = ',i5,' is not on the split surface.')
              stop
            endif
! ........end if 2nd iteration
          endif
        endif
! ....end of loop through triangles
      enddo
!
! ***************************  R E C T A N G L E S  **************************** |
! ....loop through rectangles
      do nr = 1, NRRECTA
        ion = 0;  iout = 0
! ......loop through vertices
        do iv = 1, 4
          np = RECTANGLES(nr)%VertNo(iv)
          if (new_point(np) .eq. -3) then
            ion = ion + 1
          elseif (new_point(np) .lt. 0) then
            iout = iout + 1
          endif
! ......end of loop through vertices
        enddo
! ......if rectangle needs to be split
        if ((ion .eq. 2) .and. (iout .eq. 0)) then
          ifig = ifig + 1
! ........if 2nd interation store figure type and number
          if (iter .eq. 2) then
            figs_split(1,ifig) = 2
            figs_split(2,ifig) = nr
! ..........double check that rectangle is on the split surface
            if (.not. associated(RECTANGLES(nr)%Idata)) then
              write(*,4) nr
              stop
            elseif (RECTANGLES(nr)%Idata(1) .ne. Nsplit_MOD) then
              write(*,4) nr
4             format(' allocate_FIGS_SPLIT: nr = ',i5,' is not on the split surface.')
              stop
            endif
! ........end if 2nd iteration
          endif
! ......end rectangle needs to be split
        endif
! ....end of loop through rectangles
      enddo
! ....save number of figures to split
      nr_figs_to_split = ifig
      if (nr_figs_to_split .eq. 0) then
        write(*,*) 'allocate_FIGS_SPLIT: number of figures to split  = ',nr_figs_to_split
        stop
      endif
! ....allocate figs_to_split if 1st interations
      if (iter .eq. 1)  allocate(figs_split(2,nr_figs_to_split), STAT = status)
      if (status .ne. 0) then
        write(*,*)'allocate_FIGS_SPLIT: figs_split not allocated.'
        stop
#if I_PRINT >= 2
        write(*,*)'allocate_FIGS_SPLIT: figs_split allocated successfully.'
#endif
      endif
! ..end of loop through iterations
    enddo
#if I_PRINT >= 2
    write(*,1) nr_figs_to_split
1   format(' allocate_FIGS_SPLIT: nr_figs_to_split = ',i4)
    do i = 1, nr_figs_to_split
      if (figs_split(1,i) .eq. 1) then
        write(*,5) figs_split(2,i),TRIANGLES(figs_split(2,i))%VertNo(1), &
                                   TRIANGLES(figs_split(2,i))%VertNo(2), &
                                   TRIANGLES(figs_split(2,i))%VertNo(3)
5       format('  triangle: ',I8,';  vertices = ',3(I8))
      else
        write(*,6) figs_split(2,i),RECTANGLES(figs_split(2,i))%VertNo(1), &
                                   RECTANGLES(figs_split(2,i))%VertNo(2), &
                                   RECTANGLES(figs_split(2,i))%VertNo(3), &
                                   RECTANGLES(figs_split(2,i))%VertNo(4)
6       format(' rectangle: ',I8,';  vertices = ',4(I8))
      endif
    enddo
    call pause
#endif
#if I_PRINT >= 1
    write(*,*)'allocate_FIGS_TO_SPLIT: done!'
#endif
!
end subroutine allocate_FIGS_SPLIT
!
!
!
!------------------------------------------------------------------------
subroutine split_interface
!------------------------------------------------------------------------
! LATEST REVISION: Jul 09
!
! PURPOSE: routine generates twin planes.
!
! REMARKS: original plane must NOT be removed!
!------------------------------------------------------------------------
! MODULES
  use SPLIT_SURF
  use GMP
!------------------------------------------------------------------------
  implicit none
!------------------------------------------------------------------------
! VARIABLES
  real(8) :: s
  integer :: i,ns
  integer :: status
!------------------------------------------------------------------------
! printing flag (0,1,2)
#define I_PRINT 0
!
#if I_PRINT >= 1
    write(*,*)'split_interface: splitting interface...'
#endif
! ..add one subdomain
    NRDOMAIN = NRDOMAIN + 1
#if I_PRINT >= 2
    write(*,1) NRDOMAIN
1   format(' split_interface: adding subdomain, NRDOMAINS = ',i2)
#endif
! ..check if split surface is a plane
    if (SURFACES(Nsplit_MOD)%Type .ne. 'VecPt') then
      write(*,*) 'split_interface: CANNOT SPLIT ns = ',ns
      stop
    endif
! ..determine normal of split plane
    call norm(SURFACES(Nsplit_MOD)%Rdata(4:6), s)
    NORMAL(1:3) = SURFACES(Nsplit_MOD)%Rdata(4:6)/s
#if I_PRINT >= 2
    write(*,*)'split_interface: NORMAL = ',NORMAL(1:3)
#endif
! ..add 2 planes to GMP data structure
    do i = 1, 2
      NRSURFS = NRSURFS + 1
      if (NRSURFS .gt. MAXSU) then
        write(*,*) 'split_interface: increase MAXSU.'
        stop
      endif
      SURFACES(NRSURFS)%Type = 'VecPt'
      allocate(SURFACES(NRSURFS)%Rdata(6), STAT = status)
      if (status .ne. 0 ) then
        write(*,*)'split_interface: Rdata not allocated!'
        stop
      endif
      select case(i)
! ......plane on NEG side of split plane
        case(1)
          SURFACES(NRSURFS)%Rdata(1:3) = SURFACES(Nsplit_MOD)%Rdata(1:3) - NORMAL(1:3)*Dh1_MOD
          SURFACES(NRSURFS)%Rdata(4:6) = NORMAL(1:3)
! ......plane on POS side of split plane
        case(2)
          SURFACES(NRSURFS)%Rdata(1:3) = SURFACES(Nsplit_MOD)%Rdata(1:3) + NORMAL(1:3)*Dh2_MOD
          SURFACES(NRSURFS)%Rdata(4:6) = NORMAL(1:3)
      end select
    enddo
#if I_PRINT >= 2
    write(*,*)'************************************************************************'
    write(*,*)'split_interface: 2 planes added to GMP data structure.'
    write(*,*)'plane 1 = ', (NRSURFS - 1)
    write(*,*)'plane 2 = ', NRSURFS
    call print_GMP
#endif
#if I_PRINT >= 1
    write(*,*)'split_interface: done!'
#endif
!
end subroutine split_interface
!
!
!
!---------------------------------------------------------------------------
subroutine duplicate_POINTS_AND_CURVES
!---------------------------------------------------------------------------
! LATEST REVISION: Jul 09
!
! PURPOSE: routine generates twin points and curves connecting twin points.
!
! REMARK: classifications of points is changed!
!---------------------------------------------------------------------------
  use SPLIT_SURF
  use U2D
!---------------------------------------------------------------------------
! VARIABLES
  integer :: ifig,nt,nr,nvrt,iv,np
!---------------------------------------------------------------------------
! printing flag (0,1)
#define I_PRINT 0
!
#if I_PRINT >= 1
    write(*,*)'duplicate_POINTS_AND_CURVES: generating twin points and connecting curves.'
#endif
! ..allocate extra 2 planes for reprojecting points
    call allocate_EXTRA_PLANES
! ..loop through figures to split
    do ifig = 1, nr_figs_to_split
      select case(figs_split(1,ifig))
        case(1)
          nt = figs_split(2,ifig);  nvrt = 3
        case(2)
          nr = figs_split(2,ifig);  nvrt = 4
      end select
! ....loop through figure vertex points
      do iv = 1, nvrt
        select case(figs_split(1,ifig))
          case(1);  np = TRIANGLES(nt)%VertNo(iv)
          case(2);  np = RECTANGLES(nr)%VertNo(iv)
        end select
!
! *****************  CREATE TWIN POINT & CONN CURVE  ********************* |
!===========================================================================
!  REMARK: new_point(np) = -3  INT                                         |
!                          -2  POS_SIDE                                    |
!                          -1  NEG_SIDE                                    |
!                           0  INT^c                                       |
!===========================================================================
! ......if 1st visit to point
        if (new_point(np) .le. 0) then
          call create_TW_POINT_AND_CONN_CURVE(np)
        endif
!===========================================================================
!  REMARK: new_point(np) = twin_point  INT or INT^c = SPLIT SURFACE        |
!                          -2          POS_SIDE                            |
!                          -1          NEG_SIDE                            |
!===========================================================================
! .....end loop through figure vertices
      enddo
! ..end of loop through figures to split
    enddo
! ..deallocate extra 2 planes
    call deallocate_EXTRA_PLANES
#if I_PRINT >= 1
    write(*,*)'duplicate_POINTS_AND_CURVES: done!'
#endif
!
end subroutine duplicate_POINTS_AND_CURVES
!
!
!
!--------------------------------------------------------------------------------------------------------------
subroutine generate_remaining_CUR_TRI_REC
!--------------------------------------------------------------------------------------------------------------
! LATEST REVISION: Jul 09
!
! PURPORSE: routine generates TWIN CURVES, CONNECTING FIGURES, TWIN FIGURES
!            and updates ORIGINAL FIGURES
!
! STRUCTURE:
!
!    LOOP through figs to split
!    | LOOP through fig edges
!    | | IF 1st visit to curve
!    | | | 1. generate TWIN CURVE
!    | | | 2. generate CONN FIGURE
!    | | ENDIF
!    | ENDDO
!    | 3. modify original FIGURE
!    | 4. generate TWIN FIGURE
!    ENDDO
!
! CONTAINS: update_conforming_surface
!--------------------------------------------------------------------------------------------------------------
! MODULES
  use SPLIT_SURF
  use GMP
  use control
!--------------------------------------------------------------------------------------------------------------
  implicit none
!--------------------------------------------------------------------------------------------------------------
! VARIABLES
  integer :: ic_new,ifig,nt,nr,nedg,np,np1,iv,iv1,ie,ifound,ns,is,idec
  integer :: status
!--------------------------------------------------------------------------------------------------------------
! FUNCTIONS
  integer :: my_mod
!--------------------------------------------------------------------------------------------------------------
! printint flag (0,1,2)
#define I_PRINT 0
!
#if I_PRINT >= 1
    write(*,*)'generate_remaining_CUR_TRI_REC: generating curves, triangles, rectangles'
#endif
! ..allocate new_curves and initialize to 0
    call allocate_NEW_CURVES
    new_curves = 0
! ..loop through figures to be split
    ic_new = 0
    do ifig = 1, nr_figs_to_split
! ....select figure type
      select case(figs_split(1,ifig))
        case(1);  nt = figs_split(2,ifig);  nedg = 3
        case(2);  nr = figs_split(2,ifig);  nedg = 4
      end select
! ***********************************  TWIN CURVES & CONNECTING FIGURES  ************************************  |
! ....loop through figure edges
      do ie = 1, nedg
! ......local edge endpoints
        iv = ie;  iv1 = my_mod(iv + 1,nedg)
        select case(figs_split(1,ifig))
          case(1)
            np  = TRIANGLES(nt)%VertNo(iv)
            np1 = TRIANGLES(nt)%VertNo(iv1)
          case(2)
            np  = RECTANGLES(nr)%VertNo(iv)
            np1 = RECTANGLES(nr)%VertNo(iv1)
        end select
! ......if both vertices are on the bounding surface don't duplicate curve
        if ((new_point(np) .eq. np) .and. (new_point(np1) .eq. np1))  cycle  ! <---------------- (*)
! ......determine if curve has already been visited (curves are visited twice)
        call locate_curve(np,np1,new_curves,ic_new, ifound)
! ......if 1st visit to curve
        if (ifound .eq. 0) then
          NRCURVE = NRCURVE + 1
          if (NRCURVE .gt. MAXNC) then
            write(*,*)'generate_remaining_CUR_TRI_REC: increase MAXNC.'
            stop
          endif
          CURVES(NRCURVE)%Type = 'Seglin'                                    ! <-- TWIN CURVE
! ........endpoints of new curve are twin points of old curve
          CURVES(NRCURVE)%EndPoNo(1) = new_point(np)                         ! <-- TWIN CURVE
          CURVES(NRCURVE)%EndPoNo(2) = new_point(np1)                        ! <-- TWIN CURVE
          ic_new = ic_new + 1
          if (ic_new .gt. MAX_NEW_CURVES) then
            write(*,*)'generate_remaining_CUR_TRI_REC: increase MAX_NEW_CURVES.'
            stop
          endif
! ........update list of new curves endpoints
          new_curves(1,ic_new) = np
          new_curves(2,ic_new) = np1
!==============================================================================================================
!  REMARK: recall that we are looping over curves that need to be duplicated, see (*) above, hence at least   |
!    one curve endpoint is not on the bounding surface!                                                       |
!==============================================================================================================
! ........if 1st endpoint lays on bounding surface (hence 2nd doesn't)
          if (new_point(np) .eq. np) then
! ..........generate a new triangle
            NRTRIAN = NRTRIAN + 1
            if (NRTRIAN .gt. MAXTR) then
              write(*,*)'generate_remaining_CUR_TRI_REC: increase MAXTR.'
              stop
            endif
            TRIANGLES(NRTRIAN)%Type      = 'PlaneTri'                        ! <-- CONNECTING TRIANGLE
            TRIANGLES(NRTRIAN)%VertNo(1) = np                                ! <-- CONNECTING TRIANGLE
            TRIANGLES(NRTRIAN)%VertNo(2) = np1                               ! <-- CONNECTING TRIANGLE
            TRIANGLES(NRTRIAN)%VertNo(3) = new_point(np1)                    ! <-- CONNECTING TRIANGLE
            call update_conforming_surface(1)                                ! <-- CONNECTING TRIANGLE
          elseif (new_point(np1) .eq. np1) then
! ..........generate a new triangle
            NRTRIAN = NRTRIAN + 1
            if (NRTRIAN .gt. MAXTR) then
              write(*,*)'generate_remaining_CUR_TRI_REC: increase MAXTR.'
              stop
            endif
            TRIANGLES(NRTRIAN)%Type      = 'PlaneTri'                        ! <-- CONNECTING TRIANGLE
            TRIANGLES(NRTRIAN)%VertNo(1) = np                                ! <-- CONNECTING TRIANGLE
            TRIANGLES(NRTRIAN)%VertNo(2) = np1                               ! <-- CONNECTING TRIANGLE
            TRIANGLES(NRTRIAN)%VertNo(3) = new_point(np)                     ! <-- CONNECTING TRIANGLE
            call update_conforming_surface(1)                                ! <-- CONNECTING TRIANGLE
! ........neither endpoint lays on bounding surface, then generate a rectangle
          else
! ..........generate new rectangle
            NRRECTA = NRRECTA + 1
            if (NRRECTA .gt. MAXRE) then
              write(*,*) 'generate_remaining_CUR_TRI_REC: increase MAXRE.'
              stop
            endif
            RECTANGLES(NRRECTA)%Type      = 'BilQua'                         ! <-- CONNECTING RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(1) = np                               ! <-- CONNECTING RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(2) = np1                              ! <-- CONNECTING RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(3) = new_point(np1)                   ! <-- CONNECTING RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(4) = new_point(np)                    ! <-- CONNECTING RECTANGLE
            call update_conforming_surface(2)                                ! <-- CONNECTING RECTANGLE
         endif
! ......end if 1st visit to curve
        endif
! ....end of loop through figure edges
      enddo
! ***********************************************  TWIN FIGURE *********************************************** |
! ....select figure type
      select case(figs_split(1,ifig))
! ......figure is a triangle
        case(1)
! ........add triangle
          NRTRIAN = NRTRIAN + 1
          if (NRTRIAN .gt. MAXTR) then
            write(*,*)'generate_remaining_CUR_TRI_REC: increase MAXTR.'
            stop
          endif
! ........duplicate vertices
          do iv = 1, 3
            np = TRIANGLES(nt)%VertNo(iv)
            TRIANGLES(NRTRIAN)%VertNo(iv) = new_point(np)                    ! <-- TWIN TRIANGLE
          enddo
! ........determine whether the old and new triangle need to conform to plane on POS or NEG side
          idec = 0
          do iv = 1, 3
            np = TRIANGLES(nt)%VertNo(iv)
! ..........if np is different from its twin point idec++
            if (new_point(np) .ne. np) idec = idec + 1
          enddo
!===========================================================================
!  SELECT number of duplicated vertices:
!    0,1,2  detach original triangle from plane, if Dh1 > 0
!        3  attach original triangle to plane on NEG side
!==========================================================================
          select case(idec)
! ..........up to 2 vertices have been duplicated
            case(0,1,2)
! ............detach old triangle from the original surface if dh1>0 and not a plane triangle (presence of a plane triangle may result from successive splittings...)
!!!              if ((Dh1_MOD .gt. 0.d0) .and. (TRIANGLES(nt)%Type .ne. 'PlaneTri')) then
              if (Dh1_MOD .gt. 0.d0) then
                deallocate(TRIANGLES(nt)%Idata, STAT = status)
                if (status .ne. 0) then
                  write(*,*)'generate_remaining_CUR_TRI_REC: Idata not deallocated for nt = ',nt
                  stop
                endif
                TRIANGLES(nt)%Type = 'PlaneTri'                              ! <-- ORIG TRIANGLE
              endif
              TRIANGLES(NRTRIAN)%Type = 'PlaneTri'                           ! <-- TWIN TRIANGLE
! ..........all 3 vertices have been duplicated
            case(3)
! ............attach old triangle to the plane on NEG side
              if (Dh1_MOD .gt. 0.d0)  TRIANGLES(nt)%Idata(1) = NRSURFS - 1   ! <-- ORIG TRIANGLE
              TRIANGLES(NRTRIAN)%Type = 'PTITri'                             ! <-- TWIN TRIANGLE
              allocate(TRIANGLES(NRTRIAN)%Idata(1))
! ............attach new triangle to the plane on POS side
              TRIANGLES(NRTRIAN)%Idata(1) = NRSURFS                          ! <-- TWIN TRIANGLE
! ........end select number of duplicated vertices
          end select
! ......figure is a rectangle
        case(2)
! ........add rectangle
          NRRECTA = NRRECTA + 1
          if (NRRECTA .gt. MAXRE) then
            write(*,*)'generate_remaining_CUR_TRI_REC: increase MAXRE.'
            stop
          endif
! ........duplicate vertices
          do iv = 1, 4
            np = RECTANGLES(nr)%VertNo(iv)
            RECTANGLES(NRRECTA)%VertNo(iv) = new_point(np)                   ! <-- TWIN RECTANGLE
          enddo
! ........determine whether the old and new rectangles need to conform to new planes
          idec = 0
          do iv = 1, 4
            np = RECTANGLES(nr)%VertNo(iv)
            if (new_point(np) .ne. np)  idec = idec + 1
          enddo
! ........select number of duplicated vertices
          select case(idec)
! ..........up to 3 duplicated vertices
            case(0,1,2,3)
! ............detach old rectangle from the original surface if dh1>0
              if (Dh1_MOD .gt. 0.d0) then
                deallocate(RECTANGLES(nr)%Idata)
                RECTANGLES(nr)%Type = 'BilQua'                               ! <-- ORIG RECTANGLE
              endif
              RECTANGLES(NRRECTA)%Type = 'BilQua'                            ! <-- TWIN RECTANGLE
! ..........all vertices have been duplicated
            case(4)
              if (Dh1_MOD .gt. 0.d0) RECTANGLES(nr)%Idata(1) = NRSURFS - 1   ! <-- ORIG RECTANGLE
              RECTANGLES(NRRECTA)%Type = 'PTIRec'                            ! <-- TWIN RECTANGLE
              allocate(RECTANGLES(NRRECTA)%Idata(1), STAT = status)
              if (status .ne. 0) then
                write(*,*)'generate_remaining_CUR_TRI_REC: Idata not allocated for nr = ',nr
                stop
              endif
              RECTANGLES(NRRECTA)%Idata(1) = NRSURFS                         ! <-- TWIN RECTANGLE
          end select
#if I_PRINT >= 2
            write(*,7024) nr,NRRECTA
 7024       format('generate_remaining_CUR_TRI_REC: have duplicated rectangle ',i5,' ; twin rectangle = ',i5)
!!!            call print_GMP
#endif
! ....end select figure type
      end select
! ..end of loop through figures to split
    enddo
#if I_PRINT >= 1
    write(*,*)'generate_remaining_CUR_TRI_REC: done!'
#endif
!
    contains
!
!
!
!------------------------------------------------------------------------------------------------------
subroutine update_conforming_surface(fig_type)
!------------------------------------------------------------------------------------------------------
  use control
  use SPLIT_SURF
!------------------------------------------------------------------------------------------------------
! DUMMY ARGUMENTS
  integer, intent(in)   :: fig_type
!------------------------------------------------------------------------------------------------------
! VARIABLES
  real(8)               :: fval
  real(8), dimension(3) :: xp,dfdx
!------------------------------------------------------------------------------------------------------
! printing flag (0,1)
#define I_PRINT 0
!
! ..select figure type
    select case(fig_type)
! **********************************************  TRIANGLE  ***************************************** |
      case(1)
! ......loop through surfaces
        do is = 1, Nr_confm_MOD
          ns = Ns_confm_MOD(is)
          idec = 0
          do iv = 1, 3
            np = TRIANGLES(NRTRIAN)%VertNo(iv)
            xp(1:3) = POINTS(np)%Rdata(1:3)
            call surf(ns,xp, fval,dfdx)
            if (abs(fval) .lt. GEOM_TOL)  idec = idec + 1
          enddo
! ........if a surface was found
          if (idec .eq. 3) then
            TRIANGLES(NRTRIAN)%Type = 'PTITri'                          ! <-- CONNECTING TRIANGLE
            allocate(TRIANGLES(NRTRIAN)%Idata(1), STAT = status)
            if (status .ne. 0) then
              write(*,*)'update_conforming_surface: Idata not allocated for nt = ',NRTRIAN
            endif
            TRIANGLES(NRTRIAN)%Idata(1) = ns                            ! <-- CONNECTING TRIANGLE
#if I_PRINT >= 1
            write(*,1) NRTRIAN,ns
1           format('update_conforming_surface: attaching triangle ',I5,' to surface ', I3)
#endif
! ..........since triangle can conform only to 1 surface, exit when done
            exit
          endif
! ......end of loop through surfaces to conform to
        enddo
! **********************************************  RECTANGLE  **************************************** |
      case(2)
! ......loop through surfaces to conform to
        do is = 1, Nr_confm_MOD
          ns = Ns_confm_MOD(is)
          idec = 0
          do iv = 1, 4
            np = RECTANGLES(NRRECTA)%VertNo(iv)
            xp(1:3) = POINTS(np)%Rdata(1:3)
            call surf(ns,xp, fval,dfdx)
            if (abs(fval) .lt. GEOM_TOL)  idec = idec + 1
          enddo
! ........if a surface was found
          if (idec .eq. 4) then
            RECTANGLES(NRRECTA)%Type = 'PTIRec'                          ! <-- CONNECTING RECTANGLE
            allocate(RECTANGLES(NRRECTA)%Idata(1), STAT = status)
            if (status .ne. 0) then
              write(*,*)'update_conforming_surface: Idata not allocated for nr = ',NRRECTA
            endif
            RECTANGLES(NRRECTA)%Idata(1) = ns                            ! <-- CONNECTING RECTANGLE
#if I_PRINT >= 1
            write(*,2) NRRECTA,ns
2           format('update_conforming_surface: attaching rectangle ',I5,' to surface ', I3)
#endif
! ..........since rectangle can conform only to 1 surface, exit when done
            exit
          endif
! ......end of loop through surfaces to conform to
        enddo
      case default
        write(*,*)'update_conforming_surface: unkwon figure type.'
        stop
    end select
! ..end select figure type
!
end subroutine update_conforming_surface
!------------------------------------------------------------------------------------------------------
!
!
!
end subroutine generate_remaining_CUR_TRI_REC
!------------------------------------------------------------------------------------------------------
!
!
!

!---------------------------------------------------------------------------------
subroutine update_connectivities_ORIG_ENTITIES
!---------------------------------------------------------------------------------
! LATEST REVISION: Jul 09
!
! PURPOSE: routine updates connectivities to points for the
!          original mesh entities
!---------------------------------------------------------------------------------
  use SPLIT_SURF
!---------------------------------------------------------------------------------
  IMPLICIT NONE
!---------------------------------------------------------------------------------
  integer :: nc,ileft,iright,ion,iv,np,nt,nr,npri,ntet,npyr
!---------------------------------------------------------------------------------
! printing flag (0,1,2)
#define I_PRINT 0
!
#if I_PRINT >= 1
    write(*,*)'update_connectivities_ORIG_ENTITIES: updating connectivities...'
#endif
!---------------------------------------------------------------------------------
!  STEP 1: update CURVES --> POINTS connectivities
!
! ..loop through original curves
    do nc = 1, nrcurve_orig
      ileft = 0;  iright = 0;  ion = 0
      do iv = 1, 2
        np = CURVES(nc)%EndPoNo(iv)
! ......a twin point exists
        if (new_point(np) .gt. 0) then
          ion = ion + 1
! ......point on NEG side of split surface
        elseif (new_point(np) .eq. -1) then
          ileft = ileft + 1
! ......point on POS side of split surface
        elseif (new_point(np) .eq. -2) then
          iright = iright + 1
        endif
      enddo
      if ((ion .eq. 1) .and. (iright .eq. 1)) then
! ......loop over curve endpoints
        do iv = 1, 2
          np = CURVES(nc)%EndPoNo(iv)
! ........if endpoint has a twin point
          if (new_point(np) .gt. 0)  CURVES(nc)%EndPoNo(iv) = new_point(np)
        enddo
      endif
! ..end of loop through curves
    enddo
#if I_PRINT >= 2
    write(*,*)'update_connectivities: CURVES connectivities updated.'
#endif
!
!---------------------------------------------------------------------------------
!  STEP 2: update TRIANGLES --> POINTS connectivities
!
! ..loop through original triangles
    do nt = 1, nrtrian_orig
      ileft = 0;  iright = 0;  ion = 0
! ....loop through vertices
      do iv = 1, 3
        np = TRIANGLES(nt)%VertNo(iv)
! ......vertex was duplicated (INT)
        if ((new_point(np) .gt. 0) .and. (new_point(np) .ne. np)) then
          ion = ion + 1
! ......vertex on NEG_SIDE of split surface
        elseif (new_point(np) .eq. -1) then
          ileft = ileft + 1
! ......vertex on POS_SIDE of split surface
        elseif (new_point(np) .eq. -2) then
          iright = iright + 1
        endif
! ....end loop through vertices
      enddo
      if ((ion .gt. 0) .and. (iright .gt. 0) .and. (ileft .eq. 0)) then
        do iv = 1, 3
          np = TRIANGLES(nt)%VertNo(iv)
          if (new_point(np) .gt. 0)  TRIANGLES(nt)%VertNo(iv) = new_point(np)
        enddo
      endif
      if ((ion .gt. 0) .and. (iright .gt. 0) .and. (ileft .gt. 0)) then
        write(*,*)   'update_connectivities: triangle crossing split surface!'
        write(*,*)   '*******************  nt = ',nt
        do iv = 1, 3
          np = TRIANGLES(nt)%VertNo(iv)
          write(*,*) '**  iv,np,new_point(np) = ',iv,np,new_point(np)
        enddo
        call print_GMP
        stop
      endif
! ..end of loop through original triangles
    enddo
!
! ..loop through rectangles
      do nr=1,nrrecta_orig
        ileft=0; iright=0; ion=0
        do iv=1,4
          np = RECTANGLES(nr)%VertNo(iv)
          if ((new_point(np).gt.0).and.(new_point(np).ne.np)) then
            ion=ion+1
          elseif (new_point(np).eq.-1) then
            ileft=ileft+1
          elseif (new_point(np).eq.-2) then
            iright=iright+1
          endif
        enddo
        if ((ion.gt.0).and.(iright.gt.0).and.(ileft.eq.0)) then
          do iv=1,4
            np = RECTANGLES(nr)%VertNo(iv)
            if (new_point(np).gt.0)  RECTANGLES(nr)%VertNo(iv) = new_point(np)
          enddo
        endif
        if ((ion.gt.0).and.(iright.gt.0).and.(ileft.gt.0)) then
          write(*,*) 'split_surface: RECTANGLE CROSSING SPLIT SURFACE'
          write(*,*) 'nr = ',nr
          do iv=1,3
            np = RECTANGLES(nr)%VertNo(iv)
            write(*,*) 'iv,np,new_point(np) = ',iv,np,new_point(np)
          enddo
          call print_GMP
          stop
        endif
      enddo
!
!  ...loop through prisms
      do npri=1,nrprism_orig
#if I_PRINT >= 2
          write(*,*) 'split_surface: RECONNECTING PRISM ',npri
#endif
        ileft=0; iright=0; ion=0
        do iv=1,6
          np = PRISMS(npri)%VertNo(iv)
          if ((new_point(np).gt.0).and.(new_point(np).ne.np)) then
            ion=ion+1
          elseif (new_point(np).eq.-1) then
            ileft=ileft+1
          elseif (new_point(np).eq.-2) then
            iright=iright+1
          endif
        enddo
        if ((ion.gt.0).and.(iright.gt.0).and.(ileft.eq.0)) then
          do iv=1,6
            np = PRISMS(npri)%VertNo(iv)
            if (new_point(np).gt.0)  PRISMS(npri)%VertNo(iv) = new_point(np)
          enddo
        endif
        if ((ion.gt.0).and.(iright.gt.0).and.(ileft.gt.0)) then
          write(*,*) 'split_surface: PRISM CROSSING SPLIT SURFACE'
          stop
        endif
      enddo
!
!  ...loop through tets
      do ntet=1,nrtetra_orig
        ileft=0; iright=0; ion=0
        do iv=1,4
          np = TETRAS(ntet)%VertNo(iv)
          if ((new_point(np).gt.0).and.(new_point(np).ne.np)) then
            ion=ion+1
          elseif (new_point(np).eq.-1) then
            ileft=ileft+1
          elseif (new_point(np).eq.-2) then
            iright=iright+1
          endif
        enddo
        if ((ion.gt.0).and.(iright.gt.0).and.(ileft.eq.0)) then
          do iv=1,4
            np = TETRAS(ntet)%VertNo(iv)
            if (new_point(np).gt.0)  TETRAS(ntet)%VertNo(iv) = new_point(np)
          enddo
        endif
        if ((ion.gt.0).and.(iright.gt.0).and.(ileft.gt.0)) then
          write(*,*) 'split_surface: TET CROSSING SPLIT SURFACE'
          stop
        endif
      enddo
!
!  ...loop through pyramids
      do npyr=1,nrpyram_orig
        ileft=0; iright=0; ion=0
        do iv=1,5
          np = PYRAMIDS(npyr)%VertNo(iv)
          if ((new_point(np).gt.0).and.(new_point(np).ne.np)) then
            ion=ion+1
          elseif (new_point(np).eq.-1) then
            ileft=ileft+1
          elseif (new_point(np).eq.-2) then
            iright=iright+1
          endif
        enddo
        if ((ion.gt.0).and.(iright.gt.0).and.(ileft.eq.0)) then
          do iv=1,5
            np = PYRAMIDS(npyr)%VertNo(iv)
            if (new_point(np).gt.0) PYRAMIDS(npyr)%VertNo(iv) = new_point(np)
          enddo
        endif
        if ((ion.gt.0).and.(iright.gt.0).and.(ileft.gt.0)) then
          write(*,*) 'split_surface: PYRAMID CROSSING SPLIT SURFACE'
          stop
        endif
      enddo
#if I_PRINT >= 1
    write(*,*)'update_connectivities: done!'
#endif
!
end subroutine update_connectivities_ORIG_ENTITIES
!
!
!
!---------------------------------------------------------------------------------
subroutine generate_PRI_TET_PYR
!---------------------------------------------------------------------------------
! LATEST REVISION: Jul 09
!
! PURPOSE: routine generates new prisms, tets and pyramids
!---------------------------------------------------------------------------------
  use SPLIT_SURF
!
  implicit none
!---------------------------------------------------------------------------------
  integer :: ifig,nt,nr,ile,iv,iv1,iv2,iv3,ie,np,np1,np2,np3,flag
! FUNCTIONS
  integer :: mod3,mod4
!---------------------------------------------------------------------------------
! printing flag (0,1,2)
#define I_PRINT 0
!
#if I_PRINT >= 1
    write(*,*)'generate_PRI_TET_PYR: generating prisms, tets, pyramids...'
#endif
    flag = 0

! ..loop over figures to split
    do ifig = 1, nr_figs_to_split
      select case(figs_split(1,ifig))
! ......triangle
        case(1)
          nt = figs_split(2,ifig)
! ........determine how many points have been duplicated
          ile = 0
          do iv = 1,3
            np = TRIANGLES(nt)%VertNo(iv)
            if (new_point(np) .ne. np)  ile = ile + 1
          enddo
! ........select number of duplicated points
          select case(ile)
! ..........generate TETRA
            case(1)
              NRTETRA = NRTETRA + 1
              if (NRTETRA .gt. MAXTE) then
                write(*,*) 'generate_PRI_TET_PYR: INCREASE MAXTE'
                stop
              endif
              TETRAS(NRTETRA)%Type        = 'Linear'
              TETRAS(NRTETRA)%Domain      = NRDOMAIN
! ............loop over triangle vertices and identify duplicated point
              do iv = 1, 3
                np = TRIANGLES(nt)%VertNo(iv)
!  .............save local number of duplicated vertex
                if (new_point(np) .ne. np) then
                  iv1 = iv; exit
                endif
              enddo
!  ...........set up new tet
              do iv = 1,3
                iv2 = mod3(iv1 + iv - 1)
                TETRAS(NRTETRA)%VertNo(iv) = TRIANGLES(nt)%VertNo(iv2)
              enddo
              TETRAS(NRTETRA)%VertNo(4) = new_point(np)
!  ...........swap x and y-axis if necessary
              call check_orientation(3,NRTETRA)
#if I_PRINT >= 2
              write(*,*) 'generate_PRI_TET_PYR: GENERATED NEW TET = ',NRTETRA,TETRAS(NRTETRA)%VertNo(1:4)
#endif
! ..........generate PYRAMID
            case(2)
              NRPYRAM = NRPYRAM + 1
              if (NRPYRAM .gt. MAXPY) then
                write(*,*) 'generate_PRI_TET_PYR: INCREASE MAXPY'
                stop
              endif
              PYRAMIDS(NRPYRAM)%Type   = 'Linear'
              PYRAMIDS(NRPYRAM)%Domain = NRDOMAIN
              do ie = 1,3
                iv = ie;  iv1 = mod3(iv + 1)
                np  = TRIANGLES(nt)%VertNo(iv)
                np1 = TRIANGLES(nt)%VertNo(iv1)
                if ((new_point(np).ne.np).and.(new_point(np1).ne.np1))exit
              enddo
              PYRAMIDS(NRPYRAM)%VertNo(1) = np
              PYRAMIDS(NRPYRAM)%VertNo(2) = np1
              PYRAMIDS(NRPYRAM)%VertNo(3) = new_point(np1)
              PYRAMIDS(NRPYRAM)%VertNo(4) = new_point(np)
              iv2 = mod3(iv + 2)
              PYRAMIDS(NRPYRAM)%VertNo(5) = TRIANGLES(nt)%VertNo(iv2)
              call check_orientation(4,NRPYRAM)
! ..........generate a new prism
            case(3)
              NRPRISM = NRPRISM + 1
              if (NRPRISM .gt. MAXBT) then
                write(*,*) 'generate_PRI_TET_PYR: INCREASE MAXBT'
                stop
              endif
              PRISMS(NRPRISM)%Type   = 'Linear'
              PRISMS(NRPRISM)%Domain = NRDOMAIN
              do iv = 1, 3
                np = TRIANGLES(nt)%VertNo(iv)
                PRISMS(NRPRISM)%VertNo(iv)     = np
                PRISMS(NRPRISM)%VertNo(3 + iv) = new_point(np)
              enddo
              call check_orientation(1,NRPRISM)
            case default
              write(*,*) 'generate_PRI_TET_PYR: INCONSISTENCY 1, ile = ',ile
              stop
          end select
!
! ......split rectangle
        case(2)
          flag = 1
          nr = figs_split(2,ifig)
! ........determine how many points have been duplicated
          ile = 0
          do iv = 1, 4
            np = RECTANGLES(nr)%VertNo(iv)
            if (new_point(np) .ne. np)  ile = ile + 1
          enddo
!
          select case(ile)
!
! ........generate a new prism
          case(2)
            NRPRISM = NRPRISM + 1
            if (NRPRISM .gt. MAXBT) then
              write(*,*) 'generate_PRI_TET_PYR: INCREASE MAXBT'
              stop
            endif
            PRISMS(NRPRISM)%Type   = 'Linear'
            PRISMS(NRPRISM)%Domain = NRDOMAIN + 1
            do ie = 1, 4
              iv = ie;  iv1 = mod4(iv + 1)
              np  = RECTANGLES(nr)%VertNo(iv)
              np1 = RECTANGLES(nr)%VertNo(iv1)
              if ((new_point(np) .ne. np) .and. (new_point(np1) .eq. np1))  exit
            enddo
            PRISMS(NRPRISM)%VertNo(1) = np
            PRISMS(NRPRISM)%VertNo(2) = new_point(np)
            PRISMS(NRPRISM)%VertNo(3) = np1
            iv2 = mod4(iv + 2);  iv3 = mod4(iv + 3)
            np2 = RECTANGLES(nr)%VertNo(iv2)
            np3 = RECTANGLES(nr)%VertNo(iv3)
            PRISMS(NRPRISM)%VertNo(4) = np3
            PRISMS(NRPRISM)%VertNo(5) = new_point(np3)
            PRISMS(NRPRISM)%VertNo(6) = np2
            call check_orientation(1,NRPRISM)
#if I_PRINT >= 2
            write(*,7020) NRPRISM
 7020       format(' generate_PRI_TET_PYR: GENERATED NEW PRISM ',i6)
            write(*,7021) PRISMS(NRPRISM)%VertNo(1:6)
 7021       format(' WITH VERTEX POINTS =',6i6)
#endif
!
          case default
            write(*,*) 'generate_PRI_TET_PYR: INCONSISTENCY 2, ile = ',ile
            stop
        end select
      end select
!
! ..end of loop through figures to split
    enddo
    if (flag.eq.1) NRDOMAIN = NRDOMAIN + 1

#if I_PRINT >= 1
    write(*,*)'generate_PRI_TET_PYR: done!'
#endif
!
end subroutine generate_PRI_TET_PYR
!
!
!--------------------------------------------------------------------------------
subroutine create_TW_POINT_AND_CONN_CURVE(Np)
!--------------------------------------------------------------------------------
! LATEST REVISION: Jul 09
!
! PURPOSE: given a point, routine:
!   1. updates new_point(np) = twin_np;
!   2. if necessary:
!      a. generates twin point;
!      b. moves original point;
!      c. generates curve connecting twin points.
!--------------------------------------------------------------------------------
! MODULES
  use GMP
  use SPLIT_SURF
  use U2D
!--------------------------------------------------------------------------------
  implicit none
!--------------------------------------------------------------------------------
! DUMMY ARGUMENTS
  integer, intent(in) :: Np
!--------------------------------------------------------------------------------
! VARIABLES
  real(8) :: xp(3)
  integer :: nrsrf
  integer :: SURFS(MAXSU)
  integer :: status
!--------------------------------------------------------------------------------
! printing flag (0,1,2)
#define I_PRINT 0
!
#if I_PRINT >= 1
    write(*,*)'create_TW_POINT_AND_CONN_CURVE: Np = ',Np
#endif
! ..if point does not need to be duplicated, twin point is point itself
    if (new_point(np) .eq. 0) then
      new_point(np) = np
#if I_PRINT >= 1
      write(*,*)'create_TW_POINT_AND_CONN_CURVE: no need to duplicate point!'
#endif
      return
    endif
! *************  MOVE ORIGINAL POINT  *******************************************
    xp(1:3) = POINTS(Np)%Rdata(1:3)
! ..determine surfaces point must conform to
    call give_surf(xp,Nr_confm_MOD,Ns_confm_MOD, nrsrf,SURFS)
! ..add plane shifted on NEG side to conforming surfaces
    nrsrf = nrsrf + 1
    SURFS(nrsrf) = NRSURFS - 3
    call reproject_point(Np,nrsrf,SURFS)
!
! *************  GENERATE TWIN POINT  *******************************************
    NRPOINT = NRPOINT + 1
    if (NRPOINT .gt. MAXNP) then
      write(*,*) 'create_TW_POINT_AND_CONN_CURVE: increase MAXNP.'
      stop
    endif
    POINTS(NRPOINT)%Type  = 'Regular'
    allocate(POINTS(NRPOINT)%Rdata(1:3), STAT = status)
    if (status .ne. 0) then
      write(*,*)'create_TW_POINT_AND_CONN_CURVE: Rdata not allocated for Np = ',Np
      stop
    endif
    POINTS(NRPOINT)%Rdata(1:3) = xp(1:3)
! ..add plane shifted on POS side to conforming surfaces
    SURFS(nrsrf) = NRSURFS - 2
    call reproject_point(NRPOINT,nrsrf,SURFS)
#if I_PRINT >= 2
    write(*,*)'**************  Np = ',Np
    write(*,*)'**  conf. surfaces = ',SURFS(1:nrsrf - 1)
    write(*,*)'*****  orig. point = ',xp(1:3)
    write(*,*)'**  point NEG side = ',POINTS(Np)%Rdata(1:3)
    write(*,*)'**  point POS side = ',POINTS(NRPOINT)%Rdata(1:3)
#endif
! ..store new point to its old point connectivities
    new_point(Np) = NRPOINT
#if I_PRINT >= 2
    write(*,*)'************  twin point generated.'
#endif
!
! *************  GENERATE CONNECTING CURVE  *************************************
    NRCURVE = NRCURVE + 1
    if (NRCURVE .gt. MAXNC) then
      write(*,*)'create_TW_POINT_AND_CONN_CURVE: increase MAXNC = ',MAXNC
      stop
    endif
    CURVES(NRCURVE)%Type       = 'Seglin'
    CURVES(NRCURVE)%EndPoNo(1) = Np
    CURVES(NRCURVE)%EndPoNo(2) = NRPOINT
#if I_PRINT >= 2
    write(*,*)'************  connecting curve generated.'
#endif
#if I_PRINT >= 1
    write(*,*)'create_TW_POINT_AND_CONN_CURVE: done!'
#endif
!
end subroutine create_TW_POINT_AND_CONN_CURVE


