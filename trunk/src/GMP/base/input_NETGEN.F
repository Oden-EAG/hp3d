!----------------------------------------------------------------------
!> Purpose : routine provides an interface with NETGEN. The routine
!!           explicitly reconstructs the following connectivities:
!!              CURVES    -> POINTS
!!              TRIANGLES -> POINTS
!!           The remaining connectivities are generated by calling the
!!           routine "connect".
!
!! @revision Nov 12
!---------------------------------------------------------------------
!  NETGEN file format:
!
!     NRSURFS
!     SURFACES(1)%Type
!     SURFACES(1)%Rdata(:)   (as implied by Type)
!     ...
!
!     NRDOMAIN
!
!     NRPOINT
!     POINTS(1)%Rdata(1:3)
!     ...
!
!     NRTETRA
!     TETRAS(1)%Domain , TETRAS(1)%VertNo(1:4)
!     ...
!
!     # surface triangles
!     ns , np1 , np2 , np3
!     ...
!
!
!  Remarks :
!
!  1. Since NETGEN is a tetrahedral mesh generator, the format
!     supports tetrahedral geometries only. Blocks of different shapes
!     can be added to a NEGEN-format object through routine
!     "customize_geometry".
!
!  2. Each triangle lying on a surface needs to be listed explicitly
!     in terms of its vertex point numbers. Although the surface
!     number needs to be provided as well, the actual surface number
!     stored in the GMP data structure is determined by looping
!     through the algebraic surfaces and determining the appropriate
!     adjacency.
!
!  3. For each tet, the enumeration of the vertices dictates a
!     (local) system of coordinates for the block:
!
!        Xi_1 = (v1,v2) ; Xi_2 = (v1,v3) ; Xi_3 = (v1,v4)
!
!     If the implied system happens to be LEFT-oriented, it is
!     automatically modified into a RIGHT-oriented system by swapping
!     appropriate vertices.
!
!  4. Routine supports surface only meshes as well, namely NRTETRA=0.
!---------------------------------------------------------------------
c
C$$$      subroutine input_NETGEN_default
C$$$      call input_NETGEN_from_file(  'files/input_tets'  )
C$$$      end subroutine
C$$$c
      subroutine input_NETGEN(Fp)
c
      use control
      use GMP
      use element_data
#include "syscom.blk"
      integer, parameter :: nin = 15
      character(len=*), intent(in) :: Fp
c
c  ...point to tets connectivities (temporary)
      integer, dimension(:,:), pointer :: point_to_tets
c
c  ...number of tets connected to a point (temporary)
      integer, dimension(:),   pointer :: point_nrtets
c
      integer, dimension(2,20) :: list
      integer, dimension(3)    :: nvert_aux
c     for i-th block on the list
c       list(1,i) = block connected to an edge
c       list(2,i) = the corresponding edge number
c     or
c       list(1,i) = block connected to a face
c       list(2,i) = the corresponding face number
c
c     nvert_aux - vertices for a surface triangle
      character(10) surfstype(10), surfrtype(10)
c
c  ...list of surfaces containing a curve
      integer lists(10)
c
c  ...workspace
      dimension void(3)
c---------------------------------------------------------------------
c
      iprint = 0
c
c  ...check user defined parameters NDIM and MANDIM
      if (NDIM.ne.3) then
        write(*,1000)NDIM
1000    format(' input_NETGEN: inconsistent NDIM = ',i1)
        NDIM = 3
        write(*,1001)NDIM
1001    format('   resetting NDIM = ',i1)
      endif
      if (MANDIM.ne.3) then
        write(*,1002)MANDIM
1002    format(' input_NETGEN: inconsistent MANDIM = ',i1)
        MANDIM = 3
        write(*,1003)MANDIM
1003    format('   resetting MANDIM = ',i1)
      endif

c  ...set up the unused parameters
      NRRECTA = 0;  NRHEXAS = 0;  NRPRISM = 0;  NRPYRAM = 0
c
c  ...allocate memory for GMP data structure
      call alloc_GMP
c
c---------------------------------------------------------------------
c
c  Step 1: Input data on algebraic surfaces
c
      open(unit=nin,file=Fp,form='formatted',
     .  access='sequential',status='unknown')

ccc      write(*,*)'input_NETGEN: reading geometry file... ', Fp
c
c  ...read in number of surfaces
      read(nin,*) NRSURFS
      if (MAXSU.lt.NRSURFS) then
        write(*,7010)
 7010   format('input_NETGEN: INCREASE MAXSU')
        stop
      endif
ccc      allocate(SURFACES(MAXSU))
      if (iprint.eq.1) then
        write(*,7011)
 7011   format('input_NETGEN: READING SURFACES...')
      endif
c
      do ns=1,NRSURFS
        read(nin,*) SURFACES(ns)%Type
        if (iprint.eq.1) then
          write(*,5001) ns,SURFACES(ns)%Type
 5001     format('input_NETGEN: ns = ',i3,' SURFACE TYPE = ',a10)
        endif
c
        select case(SURFACES(ns)%Type)
c
c  .......a plane normal to a given vector and passing through
c         a point, orientation specified by the normal
          case('VecPt')
            allocate(SURFACES(ns)%Rdata(6))
            read(nin,*) SURFACES(ns)%Rdata(1:3)
            read(nin,*) SURFACES(ns)%Rdata(4:6)
c
c  .......plane passing through three given points, A,B,C
c         orientation specified by AB x AC
          case('ThrPt')
            allocate(SURFACES(ns)%Rdata(9))
            read(nin,*) SURFACES(ns)%Rdata(1:3)
            read(nin,*) SURFACES(ns)%Rdata(4:6)
            read(nin,*) SURFACES(ns)%Rdata(7:9)
c
c  .......a sphere with radius and central point
          case('Sphere')
            allocate(SURFACES(ns)%Rdata(4))
            read(nin,*) SURFACES(ns)%Rdata(1:3)
            read(nin,*) SURFACES(ns)%Rdata(4)
c
c    .....a cylinder defined with an endpoint of its axis, direction
c         vector and radius
          case('Cylinder')
            allocate(SURFACES(ns)%Rdata(7))
            read(nin,*) SURFACES(ns)%Rdata(1:3)
            read(nin,*) SURFACES(ns)%Rdata(4:6)
            read(nin,*) SURFACES(ns)%Rdata(7)
c
c  .......ellipsoid with semi-axes a,b,c along x,y,z and given central
c         point
          case('Ellipsoid')
            allocate(SURFACES(ns)%Rdata(6))
c
c  .........read coordinates of the central point
            read(nin,*) SURFACES(ns)%Rdata(1:3)
c
c  .........read semiaxes lengths
            read(nin,*) SURFACES(ns)%Rdata(4:6)
c
c  .......cone
          case('Cone')
            allocate(SURFACES(ns)%Rdata(7))
c
c  .........read coordinates of the central point
            read(nin,*) SURFACES(ns)%Rdata(1:3)
c
c  .........read direction vector
            read(nin,*) SURFACES(ns)%Rdata(4:6)
c
c  .........read the cone angle
            read(nin,*) SURFACES(ns)%Rdata(7)
c
c  .......reconstructed surface
          case('Rec')
c
c  .......other cases
          case default
            write(*,7012)
 7012       format('input_NETGEN: UNKNOWN SURFACE TYPE')
            write(*,*) SURFACES(ns)%Type
            stop 1
        end select
      enddo
c
c  ...input number of subdomains
      read(nin,*) NRDOMAIN
c
c---------------------------------------------------------------------
c
c  Step 2: Input points
c
c
c  ...read in number of points
      read(nin,*) NRPOINT
      if (MAXNP.lt.NRPOINT) then
        write(*,*) 'input_NETGEN:INCREASE MAXNP'
        stop 1
      endif
      if (iprint.eq.1) then
        write(*,*) 'input_NETGEN: READING POINTS...'
        write(*,*) '              NRPOINT = ',NRPOINT
      endif
      do np=1,NRPOINT
        POINTS(np)%Type  = 'Regular'
        allocate(POINTS(np)%Rdata(3))
        read(nin,*) POINTS(np)%Rdata(1:3)
      enddo
c
c---------------------------------------------------------------------
c  STEP 3 : read in tetrahedra. Left-oriented tets are redefined as
c           right-oriented by swapping vertices.
c---------------------------------------------------------------------
c
c  ...read in number of tets
      read(nin,*) NRTETRA
      if (NRTETRA.gt.MAXTE) then
        write(*,7013) NRTETRA, MAXTE
 7013   format(' input_NETGEN: INCREASE MAXTE, NRTETRA,MAXTE = ',2i8)
        stop
      endif
c
c  ...loop over tets
      do ntet=1,NRTETRA
        TETRAS(ntet)%Type       ='Linear'
        TETRAS(ntet)%FigNo( 1:4)=0
        TETRAS(ntet)%EdgeNo(1:6)=0
c  .....read in vertex numbers
        read(nin,*) TETRAS(ntet)%domain,TETRAS(ntet)%VertNo(1:4)
c  .....check orientation
        call check_orientation(3,ntet)
c  ...end loop over tets
      enddo
c
c---------------------------------------------------------------------
c  STEP 4 : Determine point to tets connectivities.                  |
c---------------------------------------------------------------------
c
c  ...max anticipated number of tetras connected to a point
      mptet=140
      allocate(point_to_tets(1:mptet,1:NRPOINT))
      allocate(point_nrtets(1:NRPOINT))
      point_nrtets(1:NRPOINT) = 0
c
c  ...loop through tets
      do ntet=1,NRTETRA
c
c  .....loop through tetrahedron vertex points
        do jv=1,4
c
          np = TETRAS(ntet)%VertNo(jv)
          nrtets = point_nrtets(np)
c
c  .......add the tetrahedron to the list of tetras connected to the
c         point
          nrtets = nrtets+1
          if (nrtets.gt.mptet) then
            write(*,7021) mptet
 7021       format('input_NETGEN: increase mptet = ',i3)
            stop
          endif
          point_to_tets(nrtets,np) = ntet
          point_nrtets(np) = nrtets
c
c  .....end loop through vertices
        enddo
c
c  ...end of loop through tetras
      enddo
      if (iprint.eq.1) then
        do np=1,NRPOINT
          write(*,7022) np, (point_to_tets(ii,np),ii=1,point_nrtets(np))
 7022     format('input_NETGEN: np = ',i4,' CONNECTED TETS = ',
     .           /,10i8,/,10i8,/,10i8,/,10i8,/,10i8,/,10i8,/,10i8/,10i8)
        enddo
        call pause
      endif
c
c-----------------------------------------------------------------------
c
c  Step 5: Count curves and determine temporary tets to curves
c          connectivities
c
      NRCURVE=0
c
c  ...loop through tetras
      do ntet=1,NRTETRA
c
c  .....loop through the tetrahedron edge curves
        do je=1,6
c
c  .......if the edge curve has not been defined and connected yet
          if (TETRAS(ntet)%EdgeNo(je).eq.0) then
c
c  .........initiate the counter for tets that are
c           connected to the edge
            ibl=0
c
c  .........determine the endpoints of the edge
            iv1 = TETRA_EDGE_TO_VERT(1,je)
            np1 = TETRAS(ntet)%VertNo(iv1)
            iv2 = TETRA_EDGE_TO_VERT(2,je)
            np2 = TETRAS(ntet)%VertNo(iv2)
c
c  .........loop through the tetras connected to the first endpoint
            nrtets = point_nrtets(np1)
            do k=1,nrtets
              ntet1 = point_to_tets(k,np1)
c
c  ...........locate the vertex of 'ntet1' coinciding with the first
c             endpoint
              call locate(np1,TETRAS(ntet1)%VertNo(1:4),4, kv1)
c
c  ...........lower the flag indicating that 'ntet1' shares the edge
              iflag=0
c
c  ...........loop through the edges of 'ntet1' sharing the vertex
              do l=1,3
                ie = TETRA_VERT_TO_EDGE(l,kv1)
c
c  .............look for the other vertex point
                do ive=1,2
                  iv3 = TETRA_EDGE_TO_VERT(ive,ie)
                  np3 = TETRAS(ntet1)%VertNo(iv3)
c
c  ...............raise the flag if the other endpoint has been found
                  if (np2.eq.np3) iflag=1
                enddo
c
c  .............stop the loop if the edge has been found
                if (iflag.eq.1) exit
c
c  ...........end of loop through the edges sharing the vertex
              enddo
c
c  ...........'ntet1' shares the point but not the edge, skip it
              if (iflag.eq.0) go to 10
c
c  ...........pick up the edge curve number for ntet1
              nc = TETRAS(ntet1)%EdgeNo(ie)
c
c  ...........if the curve has already been counted
              if (nc.ne.0) then
                write(*,7023) ntet,je,ntet1
 7023           format('input_NETGEN: INCONSISTENCY ntet,je,ntet1 = ',
     .                  i8,i3,i8)
                stop 1
              else
c
c  .............add 'tet1' to the list of tets to be
c               connected to the curve
                ibl=ibl+1
                list(1,ibl) = ntet1; list(2,ibl) = ie
              endif
c
 10           continue
c
c  .........end of loop through connected blocks
            enddo
c
c  .........create a new curve
            NRCURVE = NRCURVE+1
            if (NRCURVE.gt.MAXNC) then
              write(*,7024) MAXNC
 7024         format('input_NETGEN: INCREASE MAXNC = ',i10)
              stop 1
            endif
            nc = NRCURVE
            if (iprint.eq.1) then
              write(*,7025) nc,ntet,je
 7025         format('input_NETGEN: HAVE DEFINED CURVE ',i8,
     .               ' FOR TET ', i8,' AND EDGE ',i2)
              write(*,*) 'CONNECTED TETS WITH EDGE NUMBERS'
              write(*,8001) (list(1,jj),jj=1,ibl)
 8001         format(10i8)
              write(*,8001) (list(2,jj),jj=1,ibl)
ccc              call pause
            endif
c
c  .........connect all blocks from the list to the newly created curve
            nrbl = ibl
            do ibl=1,nrbl
              nbl = list(1,ibl)
              ie  = list(2,ibl)
              TETRAS(nbl)%EdgeNo(ie) = nc
            enddo
c
c  .......if the edge has not been connected yet
          endif
c
c  .....end of loop through edges of the tet
        enddo
c
c  ...end of loop through tetras
      enddo
c
c  ...define curves..................
      do nc=1,NRCURVE
        CURVES(nc)%Type = 'void'
      enddo
c
c  ...loop through tets
      do ntet=1,NRTETRA
c
c  .....loop through the tetra edge curves
        do je=1,6
c
c  .......get the connected curve
          nc = TETRAS(ntet)%EdgeNo(je)
c
c  .......if the curve is visited for the first type
          if (CURVES(nc)%Type.eq.'void') then
c
c  .........determine the endpoints of the edge
            iv1 = TETRA_EDGE_TO_VERT(1,je)
            np1 = TETRAS(ntet)%VertNo(iv1)
            iv2 = TETRA_EDGE_TO_VERT(2,je)
            np2 = TETRAS(ntet)%VertNo(iv2)
            CURVES(nc)%Type = 'Seglin'
            CURVES(nc)%EndPoNo(1) = np1
            CURVES(nc)%EndPoNo(2) = np2
            CURVES(nc)%NrFig = 0
          endif
c
c  .....end of loop through edges of the tetrahedron
        enddo
c
c  ...end of loop through tetras
      enddo
c
c  ...erase the temporary block to edge curves connectivities,
c     they will be regenarated in routine connect accounting
c     for orientation
      do ntet=1,NRTETRA
        TETRAS(ntet)%EdgeNo(1:6) = 0
      enddo
      if (iprint.eq.1) then
        do nc=1,NRCURVE
          write(*,7026) nc,(CURVES(nc)%EndPoNo(ii),ii=1,2)
 7026     format('input_NETGEN: nc,points = ',i8,2x,2i8)
        enddo
        call pause
      endif

c
c----------------------------------------------------------------------
c
c  Step 6: count triangles and determine temporary tets to face
c          triangles connectivities
c
      NRTRIAN=0
c
c  ...loop through tets
      do ntet=1,NRTETRA
c
c  .....loop through the tetra face triangles
        do jf=1,4
c
c  .......if the face has not been connected yet
          if (TETRAS(ntet)%FigNo(jf).eq.0) then
c
c  .........initiate counter for the tetras connected to the face
            ibl=0
c
c  .........determine vertex points on the face
            iv = TETRA_FACE_TO_VERT(1,jf)
            np1 = TETRAS(ntet)%VertNo(iv)
            iv = TETRA_FACE_TO_VERT(2,jf)
            np2 = TETRAS(ntet)%VertNo(iv)
            iv = TETRA_FACE_TO_VERT(3,jf)
            np3 = TETRAS(ntet)%VertNo(iv)
c
c  .........loop through the tetras connected to the first vertex point
            nrbl = point_nrtets(np1)
            do k=1,nrbl
              ntet1 = point_to_tets(k,np1)
c
c  ...........locate the vertex coinciding with the point
              call locate(np1,TETRAS(ntet1)%VertNo(1:4),4, iv1)
c
c  ...........loop through the faces sharing the point
              do l=1,3
                if = TETRA_VERT_TO_FACE(l,iv1)
c
c  .............look for two other common points
                iflag=0
                do ivf=1,3
                  iv = TETRA_FACE_TO_VERT(ivf,if)
                  np = TETRAS(ntet1)%VertNo(iv)
                  if (np.eq.np2) iflag=iflag+1
                  if (np.eq.np3) iflag=iflag+1
                enddo
                if (iflag.eq.2) exit
              enddo
              if (iflag.ne.2) go to 30
c
c  ...........look for a connected triangle
              nt = TETRAS(ntet1)%FigNo(if)
c
c  ...........if the triangle has already been created
              if (nt.ne.0) then
                write(*,7031) ntet,if,ntet1
 7031           format('input_NETGEN: INCONSISTENCY ntet,if,ntet1 = ',
     .                  i8,i3,i8)
                stop 1
              else
c
c  .............add the block to the list of blocks
c               to be connected to the curve
                ibl=ibl+1
                list(1,ibl) = ntet1; list(2,ibl) = if
              endif
c
 30           continue
c
c  .........end of loop through connected blocks
            enddo
c
c  .........no block connected to the face has been found, the
c           face rectangle has to be created
            NRTRIAN = NRTRIAN + 1
            if (NRTRIAN.gt.MAXTR) then
              write(*,7032) MAXTR
 7032         format('input_NETGEN: INCREASE MAXTR = ',i10)
              stop 1
            endif
            nt = NRTRIAN
            if (iprint.eq.1) then
              write(*,7033) nt,ntet,jf
 7033         format('input_NETGEN: HAVE DEFINED TRIANGLE ',i8,
     .               ' FOR TETRA ', i8,' AND FACE ',i2)
              write(*,*) 'CONNECTED TETS WITH FACE NUMBERS'
              write(*,8001) (list(1,jj),jj=1,ibl)
              write(*,8001) (list(2,jj),jj=1,ibl)
ccc              call pause
            endif
c
c  .........connect all blocks from the list to the rectangle
            nrbl = ibl
            do ibl=1,nrbl
              nn = list(1,ibl)
              if = list(2,ibl)
              TETRAS(nn)%FigNo(if) = nt
            enddo
c
c  .......if the face has not been connected yet
          endif
c
c  .....end of loop through faces of the tetra
        enddo
c
c  ...end of loop through tetras
      enddo
      if (iprint.eq.1) call pause
c
c
c  ...define the triangles
      do nr=1,NRTRIAN
        TRIANGLES(nr)%Type = 'void'
      enddo
c
c  ...loop through tetra
      do ntet=1,NRTETRA
c
c  .....loop through the tetra face triangles
        do jf=1,4
          nt = TETRAS(ntet)%FigNo(jf)
c
c  .......if visited for the first time
          if (TRIANGLES(nt)%Type.eq.'void') then
c
c  .........determine vertex points on the face
            iv = TETRA_FACE_TO_VERT(1,jf)
            np1 = TETRAS(ntet)%VertNo(iv)
            iv = TETRA_FACE_TO_VERT(2,jf)
            np2 = TETRAS(ntet)%VertNo(iv)
            iv = TETRA_FACE_TO_VERT(3,jf)
            np3 = TETRAS(ntet)%VertNo(iv)
            TRIANGLES(nt)%Type = 'PlaneTri'
            TRIANGLES(nt)%VertNo(1) = np1
            TRIANGLES(nt)%VertNo(2) = np2
            TRIANGLES(nt)%VertNo(3) = np3
            TRIANGLES(nt)%BlockNo(1:2) = 0
ccc            TRIANGLES(nt)%Surface = 0
c
          endif
c
c  .....end of loop through faces of the tetra
        enddo
c
c  ...end of loop through tetras
      enddo
c
c  ...erase the temporary block to face triangles connectivities,
c     they will be reconnected in routine connect accounting
c     for orientation
      do ntet=1,NRTETRA
        TETRAS(ntet)%FigNo(1:4) = 0
      enddo
      if (iprint.eq.1) then
        do nt = 1,NRTRIAN
          write(*,7034) nt,(TRIANGLES(nt)%VertNo(ii),ii=1,3)
 7034     format('input_GMPdata: nt,points = ',i8,2x,3i8)
        enddo
ccc        call pause
      endif
c
c----------------------------------------------------------------------
c  STEP 7 : read in the surface triangles, recheck the compatibility  |
c          of connected tetrahedra and redefine the triangle          |
c----------------------------------------------------------------------
c
c  ...read the number of surface triangles
      read(nin,*) no_surface_triangles
c
c  ...CASE of input file containing only surface triangle information
      if (NRTETRA.eq.0) then
        NRTRIAN=no_surface_triangles
      endif
c
c  ...loop through surface triangles
      do itsurf=1,no_surface_triangles
c
c  .....read in surface number and vertex numbers
        read(nin,*) nos, nvert_aux(1:3)
c
c  .....CASE OF SURFACE TRIANGLES ONLY.................................
        if (NRTETRA.eq.0) then
          TRIANGLES(itsurf)%Type        ='PTITri'
          TRIANGLES(itsurf)%VertNo( 1:3)=nvert_aux(1:3)
          TRIANGLES(itsurf)%BlockNo(1:2)=0
          allocate(TRIANGLES(itsurf)%Idata(1))
          TRIANGLES(itsurf)%Idata(    1)=nos
c
          call add_void_curve(nvert_aux(1),nvert_aux(2), icurve)
          call add_void_curve(nvert_aux(2),nvert_aux(3), icurve)
          call add_void_curve(nvert_aux(1),nvert_aux(3), icurve)
c
c  .....CASE OF TETS & SURFACE TRIANGLES...............................
        else
c  .......loop through surfaces
          do ns=1,NRSURFS
            ile=0
c  .........loop through vertices
            do iv=1,3
              np=nvert_aux(iv)
              call surf(ns,POINTS(np)%Rdata(1:3), fval,void)
c  ...........use a relaxed geometric tolerance
              if (abs(fval).le.GEOM_TOL*100.d0) then
ccc              if (abs(fval).le.1.d-3) then
                ile=ile+1
              endif
ccc              write(*,7093) iv,np,ns,fval
ccc 7093         format('iv,np,ns,fval = ',i2,2x,2i6,e12.5)
c  .........end of loop through vertices
            enddo
c  .........a surface was FOUND
            if (ile.eq.3) then
              if (nos.ne.ns) then
                write(*,7091) itsurf,ns,nos
 7091           format(' input_NETGEN: itsurf,ns,nos = ',i4,2i3)
                nos=ns
              endif
              goto 200
            endif
c  .......end of loop through surfaces
          enddo
c
c  .......a surface was NOT FOUUND
          write(*,7092) itsurf,nos
 7092     format(' input_NETGEN: surface not found! itsurf,nos = ',
     .           2i4)
          call pause
 200      continue
c
c  .......find the corresponding triangle in the GMP data structure
          call find_GMPtriangle(nvert_aux, nt)
c
c  .......triangle NOT FOUND
          if (nt.eq.0) then
            write(*,7041) nos,nvert_aux(1:3)
 7041       format(' input_NETGEN: HAVE NOT FOUND A TRIANGLE FOR ',
     .             'SURFACE ',i2,' VERTICES = ',3i6)
            call print_GMP
            stop
          endif
c
c  .......set up appropriate triangle Type and Idata
          select case(SURFACES(nos)%Type)
          case('Rec')  ; TRIANGLES(nt)%Type='G1RecTri'
          case default ; TRIANGLES(nt)%Type='PTITri'
            allocate(TRIANGLES(nt)%Idata(1))
            TRIANGLES(nt)%Idata(1)=nos
          endselect
c
c  .....end CASES
        endif
c
c  ...end of loop through surfaces
      enddo
c
c  ...printing
      if (iprint.eq.10) then
        write(*,7046)
 7046   format('input_NETGEN: HAVE REDEFINED SURFACE TRIANGLES')
      endif
c
c  ...deallocate temporary connectivities
      deallocate(point_to_tets,point_nrtets)
c
c
c=======================================================================
c     Activate to export phantom mesh                                  |
ccc      call connect                                                  !
c  ...volume mesh                                                      |
ccc      call export_gmp2vtk( "./files/export_phantom.vtk")            !
c  ...surface mesh                                                     |
ccc      call export_gmps2vtk("./files/export_phantom.vtk")            !
ccc      stop                                                          !
c=======================================================================
c
c
!=======================================================================
! GEOMETRY INFO SO FAR:                                                |
!                                                                      |
!        POINTS%Type         = 'Regular'                               |
!              %Rdata(1:3)   = coordinates                             |
!                                                                      |
!        CURVES%Type         = 'Seglin'                                |
!              %EndPoNo(1:2) = endpoints numbers                       |
!                                                                      |
!        TRIANGLES%Type      = 'PlaneTri','PTITri','G1RecTri'          |
!                 %VertNo    = vertex numbers                          |
!                 %Idata(1)  = surface number, if 'PTITri'             |
!                                                                      |
!        TETRAS%Type         = 'Linear'                                |
!              %VertNo(1:4)  = vertex numbers                          |
!              %Domain       = domain number                           |
!                                                                      |
!=======================================================================
c
c
c-----------------------------------------------------------------------
c  STEP 8: upgrade to double-precision geometry;
c    REMARK: only TRIANGLES%Idata(1) is needed
c
      call upgrade2double
c
c----------------------------------------------------------------------
c  STEP 9: add prisms, split surfaces and complete the GMP
c          connectivities
c
      call customize_geometry("./files/customize_geo")
!
!=======================================================================
! GEOMETRY INFO SO FAR:                                                |
!                                                                      |
!        POINTS%Type            = 'Regular'                            |
!              %Rdata(1:3)      = coordinates                          |
!                                                                      |
!        CURVES%Type            = 'Seglin'                             |
!              %EndPoNo(1:2)    = endpoints numbers                    |
!                                                                      |
!        TRIANGLES%Type         = 'PlaneTri','PTITri','G1RecTri'       |
!                 %VertNo       = vertex numbers                       |
!                 %Idata(1)     = surface number, if 'PTITri'          |
!                                                                      |
!        RECTANGLES%Type        = 'BilQua','PTIRec'                    |
!                  %VertNo(1:3) = vertex numbers                       |
!                  %Idata(1)    = surface number, if 'PTIRec'          |
!                                                                      |
!        TETRAS%Type            = 'Linear'                             |
!              %VertNo(1:4)     = vertex nembers                       |
!              %Domain          = domain number                        |
!                                                                      |
!        PYRAMIDS%Type          = 'Linear'                             |
!              %VertNo(1:5)     = vertex numbers                       |
!              %Domain          = domain number                        |
!                                                                      |
!        PRISMS%Type            = 'TIprism'                            |
!              %VertNo(1:6)     = vertex numbers                       |
!              %Domain          = domain number                        |
!                                                                      |
!=======================================================================
c
c  ...complete GMP connectivities
      call connect
c
c----------------------------------------------------------------------
c  STEP 10: redefine curvilinear segments
c
      do nc = 1, NRCURVE
c
c  .....initiate the number of different algebraic and reconstructed
c       surface triangles adjacent to the curve segment
        i = 0; its = 0; itr = 0
c
c  .....loop through figures connected to the curve
        do if=1,CURVES(nc)%NrFig
          nick = abs(CURVES(nc)%FigNo(if))
          call decode(nick, nf,lab)
          select case(lab)
c
c  .........triangle
            case(1)
            if ((TRIANGLES(nf)%Type.eq.'G1RecTri').or.
     .          (TRIANGLES(nf)%Type.eq.'PTITri')) then
c
c  ...........find the surface number
              ns = TRIANGLES(nf)%Idata(1)
              call locate(ns, lists,i, num)
              if (num.eq.0) then
                i=i+1; lists(i) = ns
                if (SURFACES(ns)%Type.eq.'Rec') then
                  itr=itr+1
                  surfrtype(itr) = 'G1RecTri'
                else
                  its=its+1
                  surfstype(its) = SURFACES(ns)%Type
                endif
              endif
            endif
c
c  .........rectangle
            case(2)
            if ((RECTANGLES(nf)%Type.eq.'G1RecRec').or.
     .          (RECTANGLES(nf)%Type.eq.'PTIRec')) then
c
c  ...........find the surface number
              ns = RECTANGLES(nf)%Idata(1)
              call locate(ns, lists,i, num)
              if (num.eq.0) then
                i=i+1; lists(i) = ns
                if (SURFACES(ns)%Type.eq.'Rec') then
                  itr=itr+1
                  surfrtype(itr) = 'G1RecRec'
                else
                  its=its+1
                  surfstype(its) = SURFACES(ns)%Type
                endif
              endif
            endif
           end select
        enddo
c
c  .....curve on a single algebraic surface
        if ((its.eq.1).and.(itr.eq.0)) then
          CURVES(nc)%Type = '1SurfsCur'
          allocate(CURVES(nc)%Idata(1))
          CURVES(nc)%Idata(1) = lists(1)
c
c  .....intersection of two algebraic surfaces
        elseif ((its.eq.2).and.(itr.eq.0)) then
          CURVES(nc)%Type = '2SurfsCur'
          allocate(CURVES(nc)%Idata(2))
          CURVES(nc)%Idata(1:2) = lists(1:2)
c
c  .....curve on a single reconstructed surface
        elseif ((its.eq.0).and.(itr.eq.1)) then
          CURVES(nc)%Type = '1SurfrCur'
          allocate(CURVES(nc)%Idata(1))
          CURVES(nc)%Idata(1) = lists(1)
c
c  .....intersection of two reconstructed surfaces (sharp edge)
        elseif ((its.eq.0).and.(itr.eq.2)) then
          CURVES(nc)%Type = '2SurfrCur'
          allocate(CURVES(nc)%Idata(2))
          CURVES(nc)%Idata(1:2) = lists(1:2)
c
c  .....intersection of three algebraic surfaces
        elseif ((its .eq. 3) .and. (itr .eq. 0)) then
          CURVES(nc)%Type = '3SurfsCur'
          allocate(CURVES(nc)%Idata(3))
          CURVES(nc)%Idata(1:3) = lists(1:3)
c
c  .....intersection of four algebraic surfaces
        elseif ((its .eq. 4) .and. (itr .eq. 0)) then
          CURVES(nc)%Type = '4SurfsCur'
          allocate(CURVES(nc)%Idata(4))
          CURVES(nc)%Idata(1:4) = lists(1:4)
c
c  .....other cases not supported for now...
        elseif ((its.ne.0).or.(itr.ne.0)) then
          write(*,7051) nc,its,itr
 7051     format('input_NETGEN: nc,its,itr = ',i7,2i3,
     .           ' CURVE CASE NOT SUPPORTED')
          write(*,7052) surfstype(1:its)
 7052     format('              SURFACE TYPES: ',10(2x,a10))
          call print_GMP
        endif
c
c  ...end of loop through curves
      enddo
c
c----------------------------------------------------------------------
c  STEP 11: redefine curvilinear triangles and rectangles
c
      do nt=1,NRTRIAN
        if (TRIANGLES(nt)%Type.eq.'PlaneTri') then
          nflag=0
          do ie=1,3
            nc = abs(TRIANGLES(nt)%EdgeNo(ie))
            if (CURVES(nc)%Type.ne.'Seglin') nflag=1
          enddo
          if (nflag.eq.1) TRIANGLES(nt)%Type = 'TransTri'
        endif
      enddo
c
      do nr=1,NRRECTA
        if (RECTANGLES(nr)%Type.eq.'BilQua') then
          nflag=0
          do ie=1,4
            nc = abs(RECTANGLES(nr)%EdgeNo(ie))
            if (CURVES(nc)%Type.ne.'Seglin') nflag=1
          enddo
          if (nflag.eq.1) RECTANGLES(nr)%Type = 'TraQua'
        endif
      enddo
c
c----------------------------------------------------------------------
c  STEP 12: redefine curvilinear tets, prisms and pyramids
c
      do ntet=1,NRTETRA
        nflag=0
        do ie=1,6
          nc = abs(TETRAS(ntet)%EdgeNo(ie))
          if (CURVES(nc)%Type.ne.'Seglin') nflag=1
       enddo
        do if=1,4
          if (TETRAS(ntet)%FigNo(if).eq.0) cycle
          call decode(TETRAS(ntet)%FigNo(if), nt,lab)
          if (TRIANGLES(nt)%Type.ne.'PlaneTri') nflag=1
        enddo
        if (nflag.eq.1) then
          if (iprint.eq.1) then
            write(*,*) 'input_NETGEN: REDEFINING ntet = ',ntet
          endif
          TETRAS(ntet)%Type = 'TraTet'
        endif
      enddo
c
      do npri=1,NRPRISM
        nflag=0
        do ie=1,9
          nc = abs(PRISMS(npri)%EdgeNo(ie))
          if (CURVES(nc)%Type.ne.'Seglin') nflag=1
        enddo
        do if=1,2
          if (PRISMS(npri)%FigNo(if).eq.0) cycle
          call decode(PRISMS(npri)%FigNo(if), nt,lab)
          if (TRIANGLES(nt)%Type.ne.'PlaneTri') nflag=1
        enddo
        do if=3,5
          if (PRISMS(npri)%FigNo(if).eq.0) cycle
          call decode(PRISMS(npri)%FigNo(if), nr,lab)
          if (RECTANGLES(nr)%Type.ne.'BilQua') nflag=1
        enddo
        if (nflag.eq.1) then
          if (iprint.eq.1) then
            write(*,*) 'input_NETGEN: REDEFINING npri = ',npri
          endif
          PRISMS(npri)%Type = 'TIprism'
        endif
      enddo
c
      do npyr=1,NRPYRAM
        nflag=0
        do ie=1,8
          nc = abs(PYRAMIDS(npyr)%EdgeNo(ie))
          if (CURVES(nc)%Type.ne.'Seglin') nflag=1
        enddo
        do if=1,1
          if (PYRAMIDS(npyr)%FigNo(if).eq.0) cycle
          call decode(PYRAMIDS(npyr)%FigNo(if), nr,lab)
          if (RECTANGLES(nr)%Type.ne.'BilQua') nflag=1
        enddo
        do if=2,5
          if (PYRAMIDS(npyr)%FigNo(if).eq.0) cycle
          call decode(PYRAMIDS(npyr)%FigNo(if), nt,lab)
          if (TRIANGLES(nt)%Type.ne.'PlaneTri') nflag=1
        enddo
        if (nflag.eq.1) then
          if (iprint.eq.1) then
            write(*,*) 'input_NETGEN: REDEFINING npyr = ',npyr
          endif
          PYRAMIDS(npyr)%Type = 'TIpyram'
        endif
      enddo
c
c----------------------------------------------------------------------
c  Step 12: check jacobians
c
ccc      call graphg
ccc      call check_jacobian
c
c
ccc      write(*,*)'input_NETGEN: done!'
      close(nin)
c
      end subroutine input_NETGEN
c
c
c
c
c//////////////////////////////////////////////////////////////////////
c P. Gatto, Nov 12 : since routine input_NETGEN was modified to
c                    automatically determine surface numbers, this
c                    routine is not really needed anymore.
c//////////////////////////////////////////////////////////////////////
c
c
c----------------------------------------------------------------------
c
c   routine name       - modify_NETGEN_input
c
c----------------------------------------------------------------------
c
c   latest revision    - Jul 08
c
c   purpose            - Routine scans the NETGEN input file for
c                        duplicated surfaces and modifies the data
c                        to avoid it
c
c   arguments            none
c
c---------------------------------------------------------------------
c
      subroutine modify_NETGEN_input
c
      use GMP
#include "syscom.blk"
#include "cinout.blk"
c
c  ...defines "old" to "new" surface number function
      integer, dimension(:), pointer:: no_surf
c
c  ...work space
      dimension rdata(10),nvert(3)
c
c  ...surface type
      character(len=10) :: type
c
c---------------------------------------------------------------------
c
      iprint=0
c
c  ...set up the dimension of the problem
      NDIM=3; MANDIM=3
c
c  ...set up the unused parameters
      NRRECTA=0 ; NRHEXAS=0 ; NRPRISM=0 ; NRPYRAM=0
c
c  ...allocate memory for GMP data structure
      call alloc_GMP
c
c  ...open the modified input file
      kout=30
      open(unit=kout,file='files/input_tets1',form='formatted',
     .     access='sequential',status='unknown')
c
c---------------------------------------------------------------------
c
c  Step 1: Input data on algebraic surfaces
c
c
c  ...read in number of surfaces
      read(KIN,*) NRSURFS
      if (MAXSU.lt.NRSURFS) then
        write(*,7010)
 7010   format(' modify_NETGEN_input: INCREASE MAXSU')
        stop 1
      endif
      allocate(no_surf(NRSURFS))
      no_surf(1:NRSURFS)=0
      if (iprint.eq.1) then
        write(*,7011)
 7011   format(' modify_NETGEN_input: READING SURFACES...')
      endif
c
c  ...initiate the number of surfaces after elimination of duplicated
c     surfaces
      ns=0
c
c  ...loop through surfaces in the input file
      do js=1,NRSURFS
        read(KIN,*) type
        write(*,*) ' js,type = ',js,type
c
        select case(type)
c
c  .......a plane normal to a given vector and passing through
c         a point, orientation specified by the normal
          case('VecPt')
            read(KIN,*) rdata(1:3)
            read(KIN,*) rdata(4:6)
c
c  .........check for duplication
            do is=1,ns
              iflag=0
              if (SURFACES(is)%Type.eq.'VecPt') then
                iflag=1
                do k=1,6
                  if (SURFACES(is)%Rdata(k).ne.rdata(k)) iflag=0
                enddo
                if (iprint.eq.1) then
                  write(*,*)'js,is = ',js,is
                  write(*,6001) rdata(1:6)
                  write(*,6001) SURFACES(is)%Rdata(1:6)
 6001             format(10e12.5)
                  write(*,*) 'iflag = ',iflag
                  call pause
                endif
              endif
              if (iflag.eq.1) then
                no_surf(js)=is
                write(*,*) 'modify_NETGEN_input: ELIMINATE PLANE ',js
                call pause
              endif
            enddo
            if (no_surf(js).eq.0) then
c
c  ...........new surface
              ns=ns+1; no_surf(js)=ns
              SURFACES(ns)%Type = type
              allocate(SURFACES(ns)%Rdata(6))
              SURFACES(ns)%Rdata(1:6) = rdata(1:6)
            endif
c
c  .......a sphere with radius and central point
          case('Sphere')
            read(KIN,*) rdata(1:3)
            read(KIN,*) rdata(4)
c
c  .........check for duplication
            do is=1,ns
              iflag=0
              if (SURFACES(is)%Type.eq.'Sphere') then
                iflag=1
                do k=1,4
                  if (SURFACES(is)%Rdata(k).ne.rdata(k)) iflag=0
                enddo
              endif
              if (iflag.eq.1) then
                no_surf(js)=is
                write(*,*) 'modify_NETGEN_input: ELIMINATE SPHERE ',js
                call pause
              endif
            enddo
            if (no_surf(js).eq.0) then
c
c  ...........new surface
              ns=ns+1; no_surf(js)=ns
              SURFACES(ns)%Type = type
              allocate(SURFACES(ns)%Rdata(4))
              SURFACES(ns)%Rdata(1:4) = rdata(1:4)
            endif
c
c    .....a cylinder defined with an endpoint of its axis, direction
c         vector and radius
          case('Cylinder')
            read(KIN,*) rdata(1:3)
            read(KIN,*) rdata(4:6)
            read(KIN,*) rdata(7)
c
c  .........check for duplication
            do is=1,ns
              iflag=0
              if (SURFACES(is)%Type.eq.'Cylinder') then
                write(*,*) 'is = ',is
                write(*,*) 'SURFACES(is)%Rdata = ',
     .                      SURFACES(is)%Rdata(1:7)
                write(*,*) '             rdata = ',rdata(1:7)
                call pause
                iflag=1
                do k=1,7
                  if (SURFACES(is)%Rdata(k).ne.rdata(k)) iflag=0
                enddo
              endif
              if (iflag.eq.1) then
                no_surf(js)=is
                write(*,*) 'modify_NETGEN_input: ELIMINATE CYLINDER ',js
                call pause
              endif
            enddo
            if (no_surf(js).eq.0) then
c
c  ...........new surface
              ns=ns+1; no_surf(js)=ns
              write(*,*) 'STORING DATA FOR js = ',js
              SURFACES(ns)%Type = type
              allocate(SURFACES(ns)%Rdata(7))
              SURFACES(ns)%Rdata(1:7) = rdata(1:7)
            endif
c
c  .......cone
          case('Cone')
            read(KIN,*) rdata(1:3)
            read(KIN,*) rdata(4:6)
            read(KIN,*) rdata(7)
c
c  .........check for duplication
            do is=1,ns
              iflag=0
              if (SURFACES(is)%Type.eq.'Cone') then
                iflag=1
                do k=1,7
                  if (SURFACES(is)%Rdata(k).ne.rdata(k)) iflag=0
                enddo
              endif
              if (iflag.eq.1) then
                no_surf(js)=is
                write(*,*) 'modify_NETGEN_input: ELIMINATE CONE ',js
                call pause
              endif
            enddo
            if (no_surf(js).eq.0) then
c
c  ...........new surface
              ns=ns+1; no_surf(js)=ns
              SURFACES(ns)%Type = type
              allocate(SURFACES(ns)%Rdata(7))
              SURFACES(ns)%Rdata(1:7) = rdata(1:7)
            endif
c
c  .......reconstructed surface
          case('Rec')
c
c  .......other cases
          case default
            write(*,7012)
 7012       format('modify_NETGEN_input: UNKNOWN SURFACE TYPE')
            write(*,*) type
            stop 1
        end select
      enddo
c
c  ...input number of subdomains
      read(KIN,*) NRDOMAIN
      write(kout,*) NRDOMAIN
      write(*,7500) ns,no_surf(1:NRSURFS)
 7500 format('modify_NETGEN_input: ns = ',i3,' no_surf = ',20i4)
      call pause
c
c---------------------------------------------------------------------
c
c  Step 2: Input points
c
c
c  ...read in number of points
      read(KIN,*) NRPOINT
      write(kout,*) NRPOINT
      if (MAXNP.lt.NRPOINT) then
        write(*,*) 'input_NETGEN:INCREASE MAXNP'
        stop 1
      endif
ccc      allocate(POINTS(MAXNP))
      do np=1,NRPOINT
        POINTS(np)%Type  = 'Regular'
        allocate(POINTS(np)%Rdata(3))
        read(KIN,*) POINTS(np)%Rdata(1:3)
        write(kout,8001) POINTS(np)%Rdata(1:3)
      enddo
c
c---------------------------------------------------------------------
c
c  Step 3: Input tetrahedra
c
c  ...read in number of tets
      read(KIN,*) NRTETRA
      write(kout,*) NRTETRA
      if (NRTETRA.gt.MAXTE) then
        write(*,7013) NRTETRA, MAXTE
 7013   format('input_NETGEN: INCREASE MAXTE, NRTETRA,MAXTE = ',2i8)
        stop 1
      endif
      do ntet=1,NRTETRA
        TETRAS(ntet)%Type = 'Linear'
        TETRAS(ntet)%FigNo(1:4) = 0
        TETRAS(ntet)%EdgeNo(1:6) = 0
        read(KIN,*) TETRAS(ntet)%domain,TETRAS(ntet)%VertNo(1:4)
        write(kout,8002) TETRAS(ntet)%domain,TETRAS(ntet)%VertNo(1:4)
      enddo
c
c----------------------------------------------------------------------
c
c  Step 4: for each surface (both algebraic and reconstructed)
c          read in the surface triangles and change the surface number
c          accordingly
c
c
c  ...read the number of surface triangles
      read(KIN,*) no_surface_triangles
      write(kout,*) no_surface_triangles
c
c  ...loop through surface triangles
      do itsurf=1,no_surface_triangles
        read(KIN,*) nos, nvert(1:3)
        write(kout,8002) no_surf(nos), nvert(1:3)
      enddo
c
      close(nout)
      stop
c
 8001 format(3e15.6)
 8002 format(i4,5i9)
c
      end subroutine modify_NETGEN_input
