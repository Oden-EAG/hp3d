!----------------------------------------------------------------------
!> Purpose : routine provides an interface with a Lagrange mesh
!            generator. 
!  The routine starts by reading:
!      POINTS  coordinates
!      TETS, HEXAS, PRISMS, PYRAMIDS ----->  POINTS connectivities
!  It generates then CURVES, TRIANGLES and RECTANGLES, providing
!      CURVE      --> POINTS
!      TRIANGLE   --> POINTS
!      RECTANGLE  --> POINTS
!  connectivities. The remaining connectivities needed by GMP
!  are generated by calling the  routine "connect".
!
!! @revision Jul 23
!---------------------------------------------------------------------
!  input file format:
!
!     NRDOMAIN
!
!     NRPOINT
!     POINTS(1)%Rdata(1:3)
!     ...
!
!     NRHEXAS
!     HEXAS(1)%Domain , HEXAS(1)%VertNo(1:8)
!     ...
!
!     NRTETRA
!     TETRAS(1)%Domain , TETRAS(1)%VertNo(1:4)
!     ...
!
!     NRPRISM
!     PRISMS(1)%Domain , PRISMS(1)%VertNo(1:4)
!     ...
!
!     NRPYRAM
!     PYRAMIDS(1)%Domain , PYRAMIDS(1)%VertNo(1:4)
!     ...
!
!  Remarks :
!
!
!  1. For each element (block), the enumeration of the vertices dictates a
!     (local) system of coordinates for the element. For instance, for
!     a tet:
!
!        Xi_1 = (v1,v2) ; Xi_2 = (v1,v3) ; Xi_3 = (v1,v4)
!
!     If the implied system happens to be LEFT-oriented, it is
!     automatically modified into a RIGHT-oriented system by swapping
!     appropriate vertices.
!
!  2. Routine supports surface only meshes as well.
!---------------------------------------------------------------------
!
      subroutine input_LAGRANGE(Fp)
!
      use control
      use GMP
      use element_data
      implicit none
      character(len=*), intent(in) :: Fp
!
      integer, parameter :: nin = 16
!
!  ...point to blocks connectivities (temporary)
      integer, dimension(:,:), pointer :: point_to_blocks
!
!  ...number of blocks connected to a point (temporary)
      integer, dimension(:),   pointer :: point_nrblocks
!
      integer :: list_blk(2,20)
!     for i-th block on the list
!       list_blk(1,i) = block connected to an edge 
!       list_blk(2,i) = the corresponding edge number
!     or
!       list_blk(1,i) = block connected to a face
!       list_blk(2,i) = the corresponding face number
!
      integer :: iprint,ntype,ftype,ibl,ibl1,ie,iv,iv1,iv2,iv3,iv4,je,&
                 jf,jj,jv,kf,lab,mpblock,nbl,nc,nf,np,np1,np2,np3,np4, &
                 npri,nhex,ntet,npyr,nr,nr1,nr2,nr3,nr_blk,nrblocks,nt
!
!
!---------------------------------------------------------------------
!
      iprint=0
      open(unit=nin,file=Fp, &
         form='formatted',access='sequential',status='old',action='read')
!
!  ...check user defined parameters NDIM and MANDIM
      read(nin,*) NDIM, MANDIM
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: NDIM, MANDIM = ',NDIM, MANDIM
      endif
!
      if (NDIM.ne.3) then
        write(*,1000) NDIM
 1000   format(' input_LAGRANGE: inconsistent NDIM = ',i1)
        NDIM = 3
        write(*,1001) NDIM
 1001   format('                 resetting NDIM = ',i1)
      endif
      if (MANDIM.ne.3) then
        write(*,1002) MANDIM
 1002   format(' input_LAGRANGE: inconsistent MANDIM = ',i1)
        MANDIM = 3
        write(*,1003) MANDIM
 1003   format('                 resetting MANDIM = ',i1)
      endif
!
!  ...allocate memory for GMP data structure
      call alloc_GMP
!
!---------------------------------------------------------------------
!
!  ...input number of subdomains
      read(nin,*) NRDOMAIN
!
!---------------------------------------------------------------------
!
!  Step 1: Input points
!
!---------------------------------------------------------------------
!
!  ...read in number of points
      read(nin,*) NRPOINT
      if (MAXNP.lt.NRPOINT) then
        write(*,*) 'input_LAGRANGE: NRPOINT, MAXNP = ', NRPOINT, MAXNP
        stop 1
      endif
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: READING POINTS...'
        write(*,*) '                NRPOINT = ',NRPOINT
      endif
      do np=1,NRPOINT
        POINTS(np)%Type  = 'Regular'
        allocate(POINTS(np)%Rdata(3))
        read(nin,*) POINTS(np)%Rdata(1:3)
      enddo
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: HAVE READ POINTS'
      endif
!
!---------------------------------------------------------------------
!
!  STEP 2 : read in tetrahedra. Left-oriented tets are redefined as
!           right-oriented by swapping vertices.
!
!---------------------------------------------------------------------
!
!  ...read in number of tets
      read(nin,*) NRTETRA
      if (NRTETRA.gt.MAXTE) then
        write(*,7010) NRTETRA, MAXTE
 7010   format(' input_LAGRANGE: NRTETRA, MAXTE = ',2i8)
        stop 1
      endif
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: READING ',NRTETRA,' TETS'
      endif
!
!  ...loop over tets
      do ntet=1,NRTETRA
        TETRAS(ntet)%Type       ='Linear'
        TETRAS(ntet)%FigNo( 1:4)=0
        TETRAS(ntet)%EdgeNo(1:6)=0
!
!  .....read in domain and vertex numbers
        read(nin,*) TETRAS(ntet)%domain,TETRAS(ntet)%VertNo(1:4)
!
!  .....check orientation
        call check_orientation(3,ntet)
!
!  ...end of loop over tets
      enddo
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: HAVE READ TETS'
      endif
!
!---------------------------------------------------------------------
!
!  STEP 3 : read in hexahedra. Left-oriented hexas are redefined as
!           right-oriented by swapping vertices.
!
!---------------------------------------------------------------------
!
!  ...read in number of hexas
      read(nin,*) NRHEXAS
      if (NRHEXAS.gt.MAXHE) then
        write(*,7020) NRHEXAS, MAXHE
 7020   format(' input_LAGRANGE: NRHEXAS, MAXHE = ',2i8)
        stop 1
      endif
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: READING ',NRHEXAS,' HEXAS'
      endif
!
!  ...loop over hexas
      do nhex=1,NRHEXAS
        HEXAS(nhex)%Type        ='Linear'
        HEXAS(nhex)%FigNo( 1:6) =0
        HEXAS(nhex)%EdgeNo(1:12)=0
!
!  .....read in domain and vertex numbers
        read(nin,*) HEXAS(nhex)%domain,HEXAS(nhex)%VertNo(1:8)
!
!  .....check orientation
        call check_orientation(2,nhex)
!
!  ...end of loop over hexas
      enddo
!
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: HAVE READ HEXAS'
      endif

!---------------------------------------------------------------------
!
!  STEP 4 : read in prisms. Left-oriented prisms are redefined as
!           right-oriented by swapping vertices.
!
!---------------------------------------------------------------------
!
!  ...read in number of prisms
      read(nin,*) NRPRISM
      if (NRPRISM.gt.MAXBT) then
        write(*,7030) NRPRISM, MAXBT
 7030   format(' input_LAGRANGE: NRPRISM, MAXBT = ',2i8)
        stop 1
      endif
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: READING ',NRPRISM,' PRISMS'
      endif
!
!  ...loop over prisms
      do npri=1,NRPRISM
        PRISMS(npri)%Type       ='Linear'
        PRISMS(npri)%FigNo( 1:5)=0
        PRISMS(npri)%EdgeNo(1:9)=0
!
!  .....read in domain and vertex numbers
        read(nin,*) PRISMS(npri)%domain,PRISMS(npri)%VertNo(1:6)
!
!  .....check orientation
        call check_orientation(1,npri)
!
!  ...end of loop over prisms
      enddo
!
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: HAVE READ PRISMS'
      endif
!
!---------------------------------------------------------------------
!
!  STEP 5 : read in pyramids. Left-oriented pyramids are redefined as
!           right-oriented by swapping vertices.
!
!---------------------------------------------------------------------
!
!  ...read in number of pyramids
      read(nin,*) NRPYRAM
      if (NRPYRAM.gt.MAXPY) then
        write(*,7040) NRPYRAM, MAXPY
 7040   format(' input_LAGRANGE: NRPYRAM, MAXPY = ',2i8)
        stop 1
      endif
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: READING ',NRPYRAM,' PYRAMIDS'
      endif
!
!  ...loop over pyramids
      do npyr=1,NRPYRAM
        PYRAMIDS(npyr)%Type       ='Linear'
        PYRAMIDS(npyr)%FigNo( 1:5)=0
        PYRAMIDS(npyr)%EdgeNo(1:8)=0
!
!  .....read in domain and vertex numbers
        read(nin,*) PYRAMIDS(npyr)%domain,PYRAMIDS(npyr)%VertNo(1:5)
!
!  .....check orientation
        call check_orientation(4,npyr)
!
!  ...end of loop over pyramids
      enddo
!
      if (iprint.eq.1) then
        write(*,*) 'input_LAGRANGE: HAVE READ PYRAMIDS'
      endif
!
!---------------------------------------------------------------------
!
!  STEP 6 : Determine point to blocks connectivities.                  
!
!---------------------------------------------------------------------
!
!  ...max anticipated number of blocks connected to a point
      mpblock=140
      allocate(point_to_blocks(1:mpblock,1:NRPOINT))
      allocate(point_nrblocks(1:NRPOINT))
      point_nrblocks(1:NRPOINT) = 0
!
!  ...loop through all blocks
      do ibl=1,NRPRISM+NRHEXAS+NRTETRA+NRPYRAM
!
!  .....determine type of block
        if (ibl.le.NRPRISM) then
          ntype = PRIS; npri = ibl; nbl = npri*10+1
        elseif (ibl.le.NRPRISM+NRHEXAS) then
          ntype = BRIC; nhex = ibl - NRPRISM; nbl = nhex*10+2
        elseif (ibl.le.NRPRISM+NRHEXAS+NRTETRA) then
          ntype = TETR; ntet = ibl - NRPRISM - NRHEXAS; nbl = ntet*10+3
        else
          ntype = PYRA; npyr = ibl - NRPRISM - NRHEXAS - NRTETRA; nbl = npyr*10+4
        endif
!
!  .....loop through the points connected to the block
        do jv=1,NVERT(ntype)
          select case(ntype)
          case(PRIS)
            np = PRISMS(npri)%VertNo(jv)
          case(BRIC)
            np = HEXAS(nhex)%VertNo(jv)
          case(TETR)
            np = TETRAS(ntet)%VertNo(jv)
          case(PYRA)
            np = PYRAMIDS(npyr)%VertNo(jv)
          end select
          nrblocks = point_nrblocks(np)
!
!  .......add the block to the list of blocks connected to the point
          nrblocks = nrblocks+1
          if (nrblocks.gt.mpblock) then
            write(*,7050) mpblock
 7050       format('input_LAGRANGE: increase mpblock = ',i3)
            stop 1
          endif
          point_to_blocks(nrblocks,np) = nbl
          point_nrblocks(np) = nrblocks
!
!  .....end of loop through vertex points
        enddo
!
!  ...end of loop through blocks
      enddo
!
      if (iprint.eq.1) then
        do np=1,NRPOINT
          write(*,7060) np, (point_to_blocks(iv,np),iv=1,point_nrblocks(np))
 7060     format('input_LAGRANGE: np = ',i4,' CONNECTED BLOCKS = ', &
                 /,10i8,/,10i8,/,10i8,/,10i8,/,10i8,/,10i8,/,10i8/,10i8)
        enddo
        call pause
      endif
!
!-----------------------------------------------------------------------
!
!  Step 7: Define curves and determine temporary blocks to curves
!          connectivities
!
      NRCURVE=0
!
!  ...loop through all blocks
      do ibl=1,NRPRISM+NRHEXAS+NRTETRA+NRPYRAM
!
!  .....determine type of block
        if (ibl.le.NRPRISM) then
          ntype = PRIS; npri = ibl
        elseif (ibl.le.NRPRISM+NRHEXAS) then
          ntype = BRIC; nhex = ibl - NRPRISM
        elseif (ibl.le.NRPRISM+NRHEXAS+NRTETRA) then
          ntype = TETR; ntet = ibl - NRPRISM - NRHEXAS
        else
          ntype = PYRA; npyr = ibl - NRPRISM - NRHEXAS - NRTETRA
        endif
!
!  .....loop through the curves connected to the block
        do je=1,NEDGE(ntype)
!
!  .......quit if the curve has already been defined and connected
          select case(ntype)
          case(PRIS); if (PRISMS(npri)%EdgeNo(je).ne.0)   cycle
          case(BRIC); if (HEXAS(nhex)%EdgeNo(je).ne.0)    cycle
          case(TETR); if (TETRAS(ntet)%EdgeNo(je).ne.0)   cycle
          case(PYRA); if (PYRAMIDS(npyr)%EdgeNo(je).ne.0) cycle
          end select
!
!  .......determine the endpoints of the edge
          call edge_to_vert(ntype,je, iv1,iv2)
          select case(ntype)
          case(PRIS)
            np1 = PRISMS(npri)%VertNo(iv1);   np2 = PRISMS(npri)%VertNo(iv2)
          case(BRIC)
            np1 = HEXAS(nhex)%VertNo(iv1);    np2 = HEXAS(nhex)%VertNo(iv2)
          case(TETR)
            np1 = TETRAS(ntet)%VertNo(iv1);   np2 = TETRAS(ntet)%VertNo(iv2)
          case(PYRA)
            np1 = PYRAMIDS(npyr)%VertNo(iv1); np2 = PYRAMIDS(npyr)%VertNo(iv2)
          end select
          nr1 = point_nrblocks(np1)
          nr2 = point_nrblocks(np2)
!
!  .......find blocks connected to the curve
          call find_curve_blocks(np1,nr1,point_to_blocks(1:nr1,np1),  &
                                 np2,nr2,point_to_blocks(1:nr2,np2),  &
                                 list_blk,20,nr_blk)
!
!  .......create a new curve and connect it to the blocks
          NRCURVE = NRCURVE+1
          if (NRCURVE.gt.MAXNC) then
            write(*,7070) MAXNC
 7070       format('input_LAGRANGE: INCREASE MAXNC = ',i10)
            stop 1
          endif
          nc = NRCURVE
          CURVES(nc)%Type = 'Seglin'
          CURVES(nc)%EndPoNo(1) = np1
          CURVES(nc)%EndPoNo(2) = np2
          CURVES(nc)%NrFig = 0
!
!  .......connect all blocks from the list to the newly created curve
          do ibl1=1,nr_blk
            call decode(list_blk(1,ibl1), nbl, lab)
            ie  = list_blk(2,ibl1)
            select case(lab)
            case(1); PRISMS(nbl)%EdgeNo(ie)   = nc
            case(2); HEXAS(nbl)%EdgeNo(ie)    = nc
            case(3); TETRAS(nbl)%EdgeNo(ie)   = nc
            case(4); PYRAMIDS(nbl)%EdgeNo(ie) = nc
            end select
          enddo
          if (iprint.eq.1) then
            write(*,7080) nc,ntype,je
 7080       format('input_LAGRANGE: HAVE DEFINED CURVE ',i8, &
                   ' FOR NTYPE ', i2,' AND EDGE ',i2)
            write(*,*) 'CONNECTED BLOCKS WITH EDGE NUMBERS'
            write(*,8010) (list_blk(1,jj),jj=1,nr_blk)
 8010       format(10i8)
            write(*,8010) (list_blk(2,jj),jj=1,nr_blk)
            call pause
          endif
!
!  .....end of loop through edges
        enddo
!
!  ...end of loop through blocks
      enddo
!
!  ...erase the temporary block to edge curves connectivities,
!     they will be regenerated in routine connect accounting
!     for orientation
!
!  ...loop through all blocks
      do ibl=1,NRPRISM+NRHEXAS+NRTETRA+NRPYRAM
!
        if (ibl.le.NRPRISM) then
          npri = ibl; PRISMS(npri)%EdgeNo(1:9) = 0
        elseif (ibl.le.NRPRISM+NRHEXAS) then
          nhex = ibl - NRPRISM; HEXAS(nhex)%EdgeNo(1:12) = 0
        elseif (ibl.le.NRPRISM+NRHEXAS+NRTETRA) then
          ntet = ibl - NRPRISM - NRHEXAS; TETRAS(ntet)%EdgeNo(1:6) = 0
        else
          npyr = ibl - NRPRISM - NRHEXAS - NRTETRA; PYRAMIDS(npyr)%EdgeNo(1:8) = 0
        endif
!
      enddo
      if (iprint.ge.1) then
        do nc=1,NRCURVE
          write(*,7090) nc,(CURVES(nc)%EndPoNo(ie),ie=1,2)
 7090     format('input_LAGRANGE: nc,points = ',i8,2x,2i8)
        enddo
        call pause
      endif

!
!----------------------------------------------------------------------
!
!  Step 8: Define triangles and rectangles and determine temporary block to face
!          triangles connectivities
!
      NRTRIAN=0; NRRECTA=0
!
!  ...loop through all blocks
      do ibl=1,NRPRISM+NRHEXAS+NRTETRA+NRPYRAM
!
!  .....determine type of block
        if (ibl.le.NRPRISM) then
          ntype = PRIS; npri = ibl
        elseif (ibl.le.NRPRISM+NRHEXAS) then
          ntype = BRIC; nhex = ibl - NRPRISM
        elseif (ibl.le.NRPRISM+NRHEXAS+NRTETRA) then
          ntype = TETR; ntet = ibl - NRPRISM - NRHEXAS
        else
          ntype = PYRA; npyr = ibl - NRPRISM - NRHEXAS - NRTETRA
        endif
!
!  .....loop through figures connected to the block
        do jf=1,nface(ntype)
!
!  .......quit if the figure has already been defined and connected
          select case(ntype)
          case(PRIS); if (PRISMS(npri)%FigNo(jf).ne.0)   cycle
          case(BRIC); if (HEXAS(nhex)%FigNo(jf).ne.0)    cycle
          case(TETR); if (TETRAS(ntet)%FigNo(jf).ne.0)   cycle
          case(PYRA); if (PYRAMIDS(npyr)%FigNo(jf).ne.0) cycle
          end select
!
!  .......determine the endpoints of the face
          call face_to_vert(ntype,jf, iv1,iv2,iv3,iv4)
          select case(ntype)
          case(PRIS)
            select case(jf)
            case(1,2) ; ftype = TRIA
            case(3,4,5); ftype = RECT
            end select
            np1 = PRISMS(npri)%VertNo(iv1);   np2 = PRISMS(npri)%VertNo(iv2)
            np3 = PRISMS(npri)%VertNo(iv3);   np4 = PRISMS(npri)%VertNo(iv4)
          case(BRIC)
            ftype = RECT
            np1 = HEXAS(nhex)%VertNo(iv1);    np2 = HEXAS(nhex)%VertNo(iv2)
            np3 = HEXAS(nhex)%VertNo(iv3);    np4 = HEXAS(nhex)%VertNo(iv4)
          case(TETR)
            ftype = TRIA
            np1 = TETRAS(ntet)%VertNo(iv1);   np2 = TETRAS(ntet)%VertNo(iv2)
            np3 = TETRAS(ntet)%VertNo(iv3)
          case(PYRA)
            select case(jf)
            case(1) ; ftype = RECT
            case(2,3,4,5); ftype = TRIA
            end select
            np1 = PYRAMIDS(npyr)%VertNo(iv1); np2 = PYRAMIDS(npyr)%VertNo(iv2)
            np3 = PYRAMIDS(npyr)%VertNo(iv3); np4 = PYRAMIDS(npyr)%VertNo(iv4)
          end select
          nr1 = point_nrblocks(np1)
          nr2 = point_nrblocks(np2)
          nr3 = point_nrblocks(np3)
!
!  .......determine blocks adjacent to the face
          call find_figure_blocks(np1,nr1,point_to_blocks(1:nr1,np1), &
                                  np2,nr2,point_to_blocks(1:nr2,np2), &
                                  np3,nr3,point_to_blocks(1:nr3,np3), &
                                  list_blk,nr_blk)
          select case(ftype)
          case(TRIA)
            NRTRIAN = NRTRIAN + 1
            if (NRTRIAN.gt.MAXTR) then
              write(*,7100) MAXTR
 7100         format('input_LAGRANGE: INCREASE MAXTR = ',i10)
              stop 1
            endif
            nf = NRTRIAN 
            TRIANGLES(nf)%Type = 'PlaneTri'
            TRIANGLES(nf)%VertNo(1) = np1
            TRIANGLES(nf)%VertNo(2) = np2
            TRIANGLES(nf)%VertNo(3) = np3
            TRIANGLES(nf)%BlockNo(1:2) = 0
            if (iprint.eq.1) then
              write(*,7110) nf,ntype,jf
 7110         format('input_LAGRANGE: HAVE DEFINED TRIANGLE ',i8, &
                     ' FOR BLOCK TYPE ', i4,' AND FACE ',i2)
              write(*,*) 'CONNECTED BLOCKS WITH FACE NUMBERS'
              write(*,8010) (list_blk(1,jj),jj=1,nr_blk)
              write(*,8010) (list_blk(2,jj),jj=1,nr_blk)
              call pause
            endif
          case(RECT)
            NRRECTA = NRRECTA + 1
            if (NRRECTA.gt.MAXRE) then
              write(*,7120) MAXRE
 7120         format('input_LAGRANGE: INCREASE MAXRE = ',i10)
              stop 1
            endif
            nf = NRRECTA
            RECTANGLES(nf)%Type = 'BilQua'
            RECTANGLES(nf)%VertNo(1) = np1
            RECTANGLES(nf)%VertNo(2) = np2
            RECTANGLES(nf)%VertNo(3) = np3
            RECTANGLES(nf)%VertNo(4) = np4
            RECTANGLES(nf)%BlockNo(1:2) = 0
            if (iprint.eq.1) then
              write(*,7130) nf,ntype,jf
 7130         format('input_LAGRANGE: HAVE DEFINED RECTANGLE ',i8, &
                     ' FOR BLOCK TYPE ', i4,' AND FACE ',i2)
              write(*,*) 'CONNECTED BLOCKS WITH FACE NUMBERS'
              write(*,8010) (list_blk(1,jj),jj=1,nr_blk)
              write(*,8010) (list_blk(2,jj),jj=1,nr_blk)
              call pause
            endif
          end select
!
!  .......connect all blocks from the list to the newly created figure
          do ibl1=1,nr_blk
            call decode(list_blk(1,ibl1), nbl, lab)
            kf  = list_blk(2,ibl1)
            select case(lab)
            case(1); PRISMS(nbl)%FigNo(kf)   = nf
            case(2); HEXAS(nbl)%FigNo(kf)    = nf
            case(3); TETRAS(nbl)%FigNo(kf)   = nf
            case(4); PYRAMIDS(nbl)%FigNo(kf) = nf
            end select
          enddo
!
!  .....end of loop through faces
        enddo
!
!  ...end of loop through blocks
      enddo
!
!  ...erase the temporary block to face figures connectivities,
!     they will be regenerated in routine connect accounting
!     for orientation 
!
!  ...loop through all blocks
      do ibl=1,NRPRISM+NRHEXAS+NRTETRA+NRPYRAM
!
        if (ibl.le.NRPRISM) then
          npri = ibl; PRISMS(npri)%FigNo(1:5) = 0
        elseif (ibl.le.NRPRISM+NRHEXAS) then
          nhex = ibl - NRPRISM; HEXAS(nhex)%FigNo(1:6) = 0
        elseif (ibl.le.NRPRISM+NRHEXAS+NRTETRA) then
          ntet = ibl - NRPRISM - NRHEXAS; TETRAS(ntet)%FigNo(1:4) = 0
        else
          npyr = ibl - NRPRISM - NRHEXAS - NRTETRA; PYRAMIDS(npyr)%FigNo(1:5) = 0
        endif
!
      enddo
      if (iprint.ge.1) then
        do nt=1,NRTRIAN
          write(*,7140) nt,(TRIANGLES(nt)%VertNo(iv),iv=1,3)
 7140     format('input_LAGRANGE: nt,points = ',i8,2x,3i8)
        enddo
        do nr=1,NRRECTA
          write(*,7150) nr,(RECTANGLES(nr)%VertNo(iv),iv=1,4)
 7150     format('input_LAGRANGE: nr,points = ',i8,2x,4i8)
        enddo
        call pause
      endif
!
!----------------------------------------------------------------------
!----------------------------------------------------------------------
!
!  ...complete GMP connectivities
      call connect
!
!  ...read surface domains data
      call read_surf_domains(nin,point_to_blocks,mpblock,point_nrblocks)
!
!----------------------------------------------------------------------
!
!  ...check jacobians
!
      if (iprint.eq.1) call graphg
      call check_jacobian
!
!
      deallocate(point_to_blocks,point_nrblocks)
!
      write(*,*)'input_LAGRANGE: DONE!'
      close(nin)
      call GMP_result
!
      end subroutine input_LAGRANGE
