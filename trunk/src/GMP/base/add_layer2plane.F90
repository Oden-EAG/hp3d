!-----------------------------------------------------------------------------------------------
subroutine add_layer2plane(N_plane,Nr_bound,Ns_bound,N_layers,Thickness,N_domains)
!-----------------------------------------------------------------------------------------------
! LATEST REVISION: Jul 09
!
! PURPOSE: routine adds N_layers prismatic layers to plane N_plane
!
! ARGUMENTS: 
!     in:
!            N_plane     - plane number (in GMP data structure)
!            Nr_bound    - number of bounding surfaces
!            Ns_bound    - list of boundig surfaces
!            N_layers    - number of prismatic layers
!            Thickness   - layers' thickness
!            N_domains   - subdomain numbers for the layers
!
!     out:   changes recorded in GMP data structure
!
! REMARKS:
!   1. plane needs to be given in 'VecPt' form and normal must point outward
!   2. for newly created POINTS, CURVES, TRIANGLES and PRISM, routine generates 
!      following connectivities:
!
!        POINTS%Type            = 'Regular'
!              %Rdata(1:3)      = coordinates
!
!        CURVES%Type            = 'Seglin'
!              %EndPoNo(1:2)    = endpoints numbers
!
!        TRIANGLES%Type         = 'PTITri'
!                 %VertNo       = vertex numbers
!                 %Idata(1)     = surface number 
!
!        RECTANGLES%Type        = 'BilQua','PTIRec'
!                  %VertNo(1:3) = vertex numbers 
!                  %Idata(1)    = surface number
!
!        PRISMS%Type            = 'TIprism'
!              %VertNo(1:6)     = vertex numbers
!              %Domain          = domain number
!
!   3. full geometry connectivities are generated by routine connect and input_NETGEN
!-----------------------------------------------------------------------------------------------
  use control
  use GMP
!-----------------------------------------------------------------------------------------------
  IMPLICIT NONE      
!-----------------------------------------------------------------------------------------------
! PARAMETER
  integer, parameter :: max_layers = 16
!-----------------------------------------------------------------------------------------------  
! DUMMY ARGUMENTS
  integer,                       intent(in) :: N_plane
  integer,                       intent(in) :: N_layers
  integer,                       intent(in) :: Nr_bound
  integer, dimension(Nr_bound),  intent(in) :: Ns_bound
  real*8, dimension(N_layers), intent(in) :: Thickness
  integer, dimension(N_layers),  intent(in) :: N_domains
!-----------------------------------------------------------------------------------------------
! LOCAL VARIABLES
  integer                            :: nrtrian_old,nrcurve_old
! for np on the plane, surface_points(np) is the first twin point of np  
  integer, allocatable, dimension(:) :: surface_points
  real*8, dimension(3,2)             :: aux
  real*8                             :: prod,dr,fval
  integer, dimension(3)              :: nverts,nvert
  real*8, dimension(3)               :: void,temp,NORMAL
  integer, dimension(0:max_layers)   :: n_planes
  real*8, dimension(max_layers)      :: tlayer
  integer                            :: i,idec,jv,np,np1,np2,np3,nt,nc,newp1,newp2
  integer                            :: status
  integer                            :: iprint
!-----------------------------------------------------------------------------------------------
! printing flag (0,1)
      iprint = 0
!
!
 20   continue
! 
! ..read in plane data
    if (SURFACES(N_plane)%Type .ne. 'VecPt') then
      write(*,7002) N_plane
7002  format(' add_layer2plane: surface ',i4,' is not a plane.')
      stop
    else
      n_planes(0) = N_plane
      NORMAL(1:3) = SURFACES(N_plane)%Rdata(4:6)
      call normalize(NORMAL)
      if (iprint .eq. 1) then
        write(*,*)'add_layer2plane: N_plane = ',N_plane      
        write(*,7003) SURFACES(N_plane)%Rdata(1:3)
7003    format(' ***************  POINT   = ',3F8.3)
        write(*,1) SURFACES(N_plane)%Rdata(4:6)
1      format(' ***************  NORMAL  = ',3F8.3)
      endif
    endif
! ..check N_layers
    if (N_layers .gt. max_layers) then
      write(*,7001) N_layers
7001  format(' add_layer2plane: increase max_layers, N_layers = ',i2)
      stop
    endif
! ..rescale thicknesses so that they sum up to 1
    dr = 0.d0
    do i = 1, N_layers
      dr = dr + Thickness(i)
    enddo
    tlayer(1:N_layers) = Thickness(1:N_layers)/dr
! ..compute cumulative thicknesses
    do i = 2, N_layers
      tlayer(i) = tlayer(i - 1) + tlayer(i)
    enddo
    if (iprint .eq. 1) then
      write(*,7030) dr
7030  format(' add_layer2plane: dr = ',f8.3)
      write(*,2) tlayer(1:N_layers)
2     format(' ************ tlayer = ',10F8.3)      
    endif
! ..allocate RECTANGLES and PRISM if necessary
    if (.not.allocated(RECTANGLES)) then
      allocate(RECTANGLES(MAXRE), STAT = status)
      if (status .ne. 0) then
        write(*,*)'add_layer2plane: RECTANGLES not allocated.'
        stop
      endif
    endif  
    if (.not.allocated(PRISMS)) then
      allocate(PRISMS(MAXBT), STAT = status)
      if (status .ne. 0) then
        write(*,*)'add_layer2plane: PRISMS not allocated.'
        stop
      endif
    endif
!
!-----------------------------------------------------------------------
!
!  ...Step 1: Add extra planes
!
    do i = 1, N_layers
      NRSURFS = NRSURFS + 1
      if (NRSURFS .gt. MAXSU) then
        write(*,7005)
 7005   format(' add_layer2plane: increase MAXSU.')
        stop
      endif
      n_planes(i) = NRSURFS
      SURFACES(NRSURFS)%Type = 'VecPt'
      allocate(SURFACES(NRSURFS)%Rdata(6), STAT = status)
      if (status .ne. 0) then
        write(*,*)'add_layer2plane: Rdata not allocated.'
        stop
      endif
      SURFACES(NRSURFS)%Rdata(1:3) = SURFACES(N_plane)%Rdata(1:3) + &
                                     NORMAL(1:3)*tlayer(i)*dr
      SURFACES(NRSURFS)%Rdata(4:6) = NORMAL(1:3)
    enddo
    if (iprint .eq. 1) then
      write(*,7006) 
 7006 format(' add_layer2plane: surfaces have been added.')
    endif
!
!-----------------------------------------------------------------------
!
!  ...Step 2: Generate the new points, "radial" curves, triangles and
!             prisms
!
    allocate(surface_points(NRPOINT), STAT = status)
    if (status .ne. 0 ) then
      write(*,*)'add_layer2plane: surface_points not allocated.'
      stop
    endif
    surface_points(1:NRPOINT) = 0
!
! ..save the original number of curves and triangles
    nrcurve_old = NRCURVE
    nrtrian_old = NRTRIAN
!
    do nt = 1, nrtrian_old
! ....check if on the truncating sphere (use both point coordinates
!     and surface adjacency info for double checking...)
      idec = 0
      do jv = 1, 3
        np = TRIANGLES(nt)%VertNo(jv)
        call surf(N_plane,POINTS(np)%Rdata(1:3), fval,void)
!----------------------------------------------------------------------------------       
!    PRINTING
        if (iprint .eq. 10) then
          write(*,7007) N_plane, POINTS(np)%Rdata(1:3), fval
 7007     format(' add_layer2plane: N_plane, point, fval = ',i3,2x,3f8.3,2x,e12.5)
            call pause
          endif
!---------------------------------------------------------------------------------          
! ......if point is on the plane
        if (abs(fval) .le. GEOM_TOL)  idec = idec + 1
      enddo
!-----------------------------------------------------------------------------------      
!       PRINTING
!!!        if (iprint.eq.1) then
        if ((iprint .eq. 1) .and. (idec .eq. 3)) then
          write(*,7008) nt,idec
 7008     format(' add_layer2plane: nt, idec = ',i5,i2)
          call pause
        endif
!-----------------------------------------------------------------------------------------
      if ((idec .eq. 3) .and. (TRIANGLES(nt)%Idata(1) .ne. N_plane)) then
        write(*,*) 'INCOMPATIBILITY FOR TRIANGLE nt = ',nt
        stop
      endif
      if (idec .eq. 3) then
!  .....check whether the triangle is oriented towards the exterior normal
        np1 = TRIANGLES(nt)%VertNo(1)
        np2 = TRIANGLES(nt)%VertNo(2)
        np3 = TRIANGLES(nt)%VertNo(3)
        aux(1:3,1) = POINTS(np2)%Rdata(1:3) - POINTS(np1)%Rdata(1:3)
        aux(1:3,2) = POINTS(np3)%Rdata(1:3) - POINTS(np1)%Rdata(1:3)
        call mixed_product(aux(1:3,1),aux(1:3,2),SURFACES(N_plane)%Rdata(4:6), prod)
        if (prod .gt. GEOM_TOL) then
          nverts(1:3) = (/np1, np2, np3/)
        elseif (prod .lt. -GEOM_TOL) then
          nverts(1:3) = (/np1, np3, np2/)
        else
          write(*,*) 'add_layer2plane: DEGENERATED TRIANGLE = ',nt
          stop
        endif
! ......loop through the triangle vertices
        do jv = 1, 3
          np = nverts(jv)
! ........if 1st visit to vertex          
          if (surface_points(np) .eq. 0) then
! ..........save twin point number
            surface_points(np) = NRPOINT + 1
! ..........generate new points and curves
            do i = 1, N_layers
              NRPOINT = NRPOINT + 1
              if (NRPOINT .gt. MAXNP) then
                write(*,7011)
 7011           format('add_layer2plane: INCREASE MAXNP')
                stop
              endif
              POINTS(NRPOINT)%Type = 'Regular'
              allocate(POINTS(NRPOINT)%Rdata(3), STAT = status)
              if (status .ne. 0) then
                write(*,*)'add_layer2plane: Rdata not allocated for twin point.'
                stop
              endif
              POINTS(NRPOINT)%Rdata(1:3) = POINTS(np)%Rdata(1:3) + &
                                           SURFACES(N_plane)%Rdata(4:6)*tlayer(i)*dr
              NRCURVE = NRCURVE + 1
              if (NRCURVE .gt. MAXNC) then
                write(*,7012)
 7012           format('add_layer2plane: INCREASE MAXNC')
                stop
              endif
              CURVES(NRCURVE)%Type = 'Seglin'
              CURVES(NRCURVE)%NrFig = 0
              select case(i)
                case(1)
                  CURVES(NRCURVE)%EndPoNo(1) = np
                  CURVES(NRCURVE)%EndPoNo(2) = NRPOINT
                case default
                  CURVES(NRCURVE)%EndPoNo(1) = NRPOINT - 1
                  CURVES(NRCURVE)%EndPoNo(2) = NRPOINT
              end select
! ..........end of loop through layers              
            enddo
!
!  .........if the new points have not been generated yet
            endif
            nvert(jv) = surface_points(np)
!
!  .......end of loop through vertices
          enddo
          if (iprint.eq.1) then
            write(*,*) 'add_layer2plane: HAVE GENERATED POINTS AND VERTICAL CURVES'
          endif
!
!  .......generate new triangles
          do i = 1, N_layers
            NRTRIAN = NRTRIAN + 1
            if (NRTRIAN .gt. MAXTR) then
              write(*,7013)
 7013         format('add_layer2plane: INCREASE MAXTR')
              stop
            endif
            TRIANGLES(NRTRIAN)%Type         = 'PTITri'
            TRIANGLES(NRTRIAN)%VertNo(1:3)  = nvert(1:3) + i - 1
            TRIANGLES(NRTRIAN)%EdgeNo(1:3)  = 0
            TRIANGLES(NRTRIAN)%BlockNo(1:2) = 0
            allocate(TRIANGLES(NRTRIAN)%Idata(1), STAT = status)
            if (status .ne. 0 ) then
              write(*,*)'add_layer2plane: Idata not allocated for triangle.'
              stop
            endif
            TRIANGLES(NRTRIAN)%Idata(1) = n_planes(i)
          enddo
          if (iprint .eq. 1) then
            write(*,*) 'add_layer2plane: HAVE GENERATED TRIANGLES'
          endif
!
!  .......generate new prisms
          do i = 1, N_layers
            NRPRISM = NRPRISM+1
            if (NRPRISM .gt. MAXBT) then
              write(*,7014)
 7014         format('add_layer2plane: INCREASE MAXBT')
              stop
            endif
            PRISMS(NRPRISM)%Type        = 'TIprism'
            PRISMS(NRPRISM)%FigNo(1:5)  = 0
            PRISMS(NRPRISM)%EdgeNo(1:9) = 0
            select case(i)
              case(1)
                PRISMS(NRPRISM)%VertNo(1:3) = nverts(1:3)
                PRISMS(NRPRISM)%VertNo(4:6) = nvert(1:3)
              case default
                PRISMS(NRPRISM)%VertNo(1:3) = nvert(1:3) + i - 2
                PRISMS(NRPRISM)%VertNo(4:6) = nvert(1:3) + i - 1
            end select
            PRISMS(NRPRISM)%Domain = N_domains(i)
          enddo
!
!  .....if a triangle on the truncating sphere
        endif  
!
!  ...end of loop through triangles
      enddo
      if (iprint.eq.1) then
        write(*,*) 'add_layer2plane: DONE WITH STEP 2'
        call pause
      endif
!
!-----------------------------------------------------------------------
!
!  ...Step 3: Generate the twin curves, and the connecting rectangles
!
!
! ..loop over original curves
    do nc = 1, nrcurve_old
! ....check if curve is on the plane (use only point coordinates)
      idec = 0
      do jv = 1, 2
        np = CURVES(nc)%EndPoNo(jv)
        call surf(N_plane,POINTS(np)%Rdata(1:3), fval,void)
        if (abs(fval) .le. GEOM_TOL)  idec = idec + 1
      enddo
      if (iprint .eq. 1) then
        write(*,7021) nc,idec
 7021   format('add_layer2plane: nc,idec = ',i5,i2)
!!!          call pause
      endif
! ....if 1 endpoint is not on the plane, cycle
      if (idec .ne. 2)   cycle
! ....get twin points of curve end points      
      np1   = CURVES(nc)%EndPoNo(1)
      newp1 = surface_points(np1)
      np2   = CURVES(nc)%EndPoNo(2)
      newp2 = surface_points(np2)
!
! ***********************************  TWIN CURVES  ******************************* |
! ....loop over layers      
      do i = 1, N_layers
        NRCURVE = NRCURVE + 1
        if (NRCURVE .gt. MAXNC) then
          write(*,7012)
          stop
        endif
        CURVES(NRCURVE)%Type = 'Seglin'
        allocate(CURVES(NRCURVE)%Idata(1), STAT = status)
        if (status .ne. 0) then
          write(*,*)'add_layer2plane: Idata not allocated for curve.'
          stop
        endif
        CURVES(NRCURVE)%Idata(1)   = n_planes(i)               ! <-- TWIN CURVES
        CURVES(NRCURVE)%NrFig      = 0                         ! <-- TWIN CURVES
        CURVES(NRCURVE)%EndPoNo(1) = newp1 + i - 1             ! <-- TWIN CURVES
        CURVES(NRCURVE)%EndPoNo(2) = newp2 + i - 1             ! <-- TWIN CURVES
! ....end of loop over layers        
      enddo
!        
! *****************************  CONNECTING RECTANGLES  ***************************** |     
! ....loop over layers
      do i = 1, N_layers
        NRRECTA = NRRECTA + 1
        if (NRRECTA .gt. MAXRE) then
          write(*,7023)
 7023     format('add_layer2plane: INCREASE MAXRE')
          stop
        endif
        RECTANGLES(NRRECTA)%Type = 'BilQua'                    ! <-- CONN RECTANGLE
        select case(i)
! ........1st connecting rectangle        
          case(1)
            RECTANGLES(NRRECTA)%VertNo(1) = np1                ! <-- CONN RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(2) = np2                ! <-- CONN RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(3) = newp2              ! <-- CONN RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(4) = newp1              ! <-- CONN RECTANGLE
! ........subsequent connecting rectangles            
          case default
            RECTANGLES(NRRECTA)%VertNo(1) = newp1 + i - 2      ! <-- CONN RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(2) = newp2 + i - 2      ! <-- CONN RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(3) = newp2 + i - 1      ! <-- CONN RECTANGLE
            RECTANGLES(NRRECTA)%VertNo(4) = newp1 + i - 1      ! <-- CONN RECTANGLE
        end select
        RECTANGLES(NRRECTA)%EdgeNo(1:4)  = 0
        RECTANGLES(NRRECTA)%BlockNo(1:2) = 0
        call update_rectangle(NRRECTA)                         ! <-- CONN RECTANGLE
! ....end of loop over layers
      enddo
!      
! ..end of loop through original curves
    enddo
!
      deallocate(surface_points)
      if (iprint .eq. 1) then
        write(*,7024)
7024    format('add_layer2plane: done!')
        call pause
      endif
!
    contains
!    
!------------------------------------------------------------------------------------------------------
subroutine update_rectangle(Nr)
!------------------------------------------------------------------------------------------------------
  use control
!------------------------------------------------------------------------------------------------------  
! DUMMY ARGUMENTS
  integer, intent(in)    :: Nr
!------------------------------------------------------------------------------------------------------  
! VARIABLES
  real*8               :: fval
  real*8, dimension(3) :: xp,dfdx
  integer              :: is,ns,idec,iv,np
  integer              :: status
!------------------------------------------------------------------------------------------------------  
! printing flag (0,1)
#define I_PRINT 0
!
! ......loop over bounding surfaces
        do is = 1, Nr_bound
          ns = Ns_bound(is)
          idec = 0
          do iv = 1, 4
            np = RECTANGLES(Nr)%VertNo(iv)
            xp(1:3) = POINTS(np)%Rdata(1:3)
            call surf(ns,xp, fval,dfdx)
            if (abs(fval) .lt. GEOM_TOL)  idec = idec + 1
          enddo
! ........if a surface was found         
          if (idec .eq. 4) then
            RECTANGLES(Nr)%Type = 'PTIRec'                               ! <-- CONN RECTANGLE
            allocate(RECTANGLES(Nr)%Idata(1), STAT = status)
            if (status .ne. 0) then
              write(*,*)'update_conforming_surface: Idata not allocated for nr = ',Nr
            endif        
            RECTANGLES(Nr)%Idata(1) = ns                                 ! <-- CONN RECTANGLE
#if I_PRINT >= 1            
            write(*,10) Nr,ns
10           format('update_conforming_surface: attaching rectangle ',I5,' to surface ', I3)
#endif
! ..........since rectangle can conform only to 1 surface, exit when done
            exit
          endif
! ......end of loop over bounding surfaces 
        enddo   
!
end subroutine update_rectangle
!------------------------------------------------------------------------------------------------------  
!
!
end subroutine add_layer2plane
